keywords() ::= <<
Asm, auto, and, and_eq, bool, bitor, bitand, break, case, catch, char, class, compl, const, const_cast, continue, default, #define, delete, do, double, dynamic_cast, else, enum, exit(), explicit, export
extern, extern "C", false, float, for, union, unsigned, using, friend, goto, if, inline, int, long, mutable, virtual, namespace, new, not, not_eq, operator, or, or_eq, private, protected, public, register, void, reinterpret_cast,
return, short, signed, sizeof, static, static_cast, volatile, struct, switch, template, this, throw, true, try, typedef, typeid, union, unsigned, using, wchar_t, while, xor, xor_eq
>>


machine(imports, machine, includes, constants, values, enums, sets, declarations, initialization, operations, addition) ::= <<
#include \<iostream>
#include \<string>
<imports; separator="\n">

using namespace std;

class <machine> {

    <enums; separator="\n\n">


    private:

        <includes; separator="\n">

        <sets; separator="\n">

        <declarations; separator="\n">

        bool initialized = false;

    public:

        <machine>(){}

        <initialization>

        <operations; separator="\n\n">

};

<addition>
>>

initialization(machine, body, machines) ::= <<
void initialize() {
    if(initialized) {
        throw runtime_error("Machine is already initialized");
    }
    <machines : {m | <include_initialization(m)>}; separator="\n">
    <body>
    initialized = true;
}
>>

include_initialization(machine) ::= <<
<machine>.initialize();
>>

operation(machine, returnType, operationName, parameters, returnParameters, locals, body, return) ::= <<
<returnType>* <operationName>(<parameters; separator=", ">) {
    if(!initialized) {
        throw runtime_error("Machine was not initialized");
    }
    <locals; separator="\n">
    <body>
    <return>
}
>>

return(identifier) ::= <<
return <identifier>;
>>

set_declaration(identifier, enums) ::= <<
#define <identifier> <set_enumeration(enums)>
>>

set_enumeration(enums) ::= <<
new BSet((BObject* []){<enums; separator=", ">})
>>

enum_call(class, identifier) ::= <<
new <class>(<class>::<identifier>)
>>

set_enum_declaration(name,enums) ::= <<
class <name> : public BObject {
    public:

        enum <name>_type {
            <enums;separator=", \n">
        };

        <name>_type value;

        <name>(<name>_type type) {
            this->value = type;
        }

        <name>(){}

        BBoolean* equal(<name>* o) {
            return BBoolean(this->value == o->value);
        }

        BBoolean* unequal(<name>* o) {
            return BBoolean(this->value != o->value);
        }

        int hashCode() const {
            return 0;
        }
};
>>

include_declaration(type, identifier) ::= <<
<declaration(type, identifier)> = new <type>();
>>

global_declaration(type, identifier) ::= <<
<declaration(type, identifier)>;
>>

local_declaration(type, identifier) ::= <<
<declaration(type, identifier)>;
>>

declaration(type, identifier) ::= <<
<type>* <identifier>
>>

constant(type, identifier, val) ::= <<
>>

values(assignments) ::= <<
>>

parameter(type, identifier, isReturn) ::= <<
<type>* <identifier>
>>

assignment(identifier, typeCast, val) ::= <<
<identifier> = <val>;
>>

assignments(assignments) ::= <<
<assignments; separator="\n">
>>

void() ::= <<
void
>>

type(type, cast) ::= <<
<type>
>>

import_type(type) ::= <<
#include "<type>.cpp"
>>


interval(arg1, arg2) ::= <<
BSet::range(<arg1>,<arg2>)
>>

couple_create(arg1, arg2) ::= <<
new BCouple(<arg1>, <arg2>)
>>


binary(arg1,operator,arg2) ::= <<
<arg1>-><operator>(<arg2>)
>>

unary(operator, obj, args) ::= <<
<obj>-><operator>(<args; separator=", ">)
>>

select(predicate, then) ::= <<
if((<predicate>)->booleanValue()) {
    <then>
} else {
    throw runtime_error("Invocation of the operation is not possible");
}
>>

if(predicate, then, else1) ::= <<
if((<predicate>)->booleanValue()) {
    <then>
} <else1; separator=" ">
>>

elseif(predicate, then) ::= <<
else if((<predicate>)->booleanValue()) {
    <then>
}
>>

else(then) ::= <<
else {
    <then>
}
>>

while(predicate, then) ::= <<
while((<predicate>)->booleanValue()) {
    <then>
}
>>

var(locals, body) ::=<<
<locals; separator="\n">
<body>
>>

boolean_val(val) ::= <<
<if(val)>new BBoolean(true)<else>new BBoolean(false)<endif>
>>

identifier(identifier, isReturn, isPrivate, rhsOnLhs) ::= <<
<identifier>
>>

number(number, useBigInteger) ::= <<
new BInteger(<number>)
>>

operation_call_with_assignment(var, machine, function, args, this) ::= <<
<function>(<args; separator=",">, <var>);
>>

operation_call_without_assignment(machine, function, args, this) ::= <<
<function>(<args; separator=",">);
>>


