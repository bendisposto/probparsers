module DataDeriver.MainTest where

import Test.QuickCheck
import DataDeriver.Main

simpleTest :: Property
simpleTest = once (getNewContents file == expected)
    where
        file =
            "{-# derive DataTypeable #-}\n"
         ++ "data Program = Program [Int]\n"
         ++ "  derive Show Program\n"
         ++ "  derive Eq Program\n"
        expected = "{-# derive DataTypeable #-}\ndata Program = Program [Int]\n  derive Show Program\n  derive Eq Program\n\n{-# autogenerated by DataDeriver #-}\ntc_Program :: TyCon\ntc_Program = mkTyCon3 \"\" \"noname\" \"Program\"\ninstance Typeable (Program ) where\n    typeOf _ = mkTyConApp tc_Program []\ncon_Program_Program :: Constr\ncon_Program_Program = mkConstr ty_Program \"Program\" [] Prefix\nty_Program :: DataType\nty_Program = mkDataType \".noname.Program\" [con_Program_Program]\ninstance Data (Program ) where\n    toConstr (Program _ _ _ _ _ _ _) = con_Program_Program\n    dataTypeOf _ = ty_Program\n    gunfold k z c = case constrIndex c of\n                         1 -> k (k (k (k (k (k (k (z Program)))))))\n                         _ -> error \"gunfold(Program)\"\n    gfoldl f z x = case x of\n                         (Program a1 a2 a3 a4 a5 a6 a7) -> (((((((z Program) `f` a1) `f` a2) `f` a3) `f` a4) `f` a5) `f` a6) `f` a7\n\n\n"

tupleTest :: Property
tupleTest = once (getNewContents file == expected)
    where
        file = "{-# derive DataTypeable #-}\ndata Point = Point (Int,Char)\n"
        expected = "{-# derive DataTypeable #-}\ndata Point = Point (Int,Char)\n\n{-# autogenerated by DataDeriver #-}\ntc_Point :: TyCon\ntc_Point = mkTyCon3 \"\" \"noname\" \"Point\"\ninstance Typeable (Point ) where\n    typeOf _ = mkTyConApp tc_Point []\ncon_Point_Point :: Constr\ncon_Point_Point = mkConstr ty_Point \"Point\" [] Prefix\nty_Point :: DataType\nty_Point = mkDataType \".noname.Point\" [con_Point_Point]\ninstance Data (Point ) where\n    toConstr (Point _) = con_Point_Point\n    dataTypeOf _ = ty_Point\n    gunfold k z c = case constrIndex c of\n                         1 -> k (z Point)\n                         _ -> error \"gunfold(Point)\"\n    gfoldl f z x = case x of\n                         (Point a1) -> (z Point) `f` a1\n\n\n"

applyTwiceTest :: Property
applyTwiceTest = once (getNewContents file == (getNewContents (getNewContents file)))
    where
        file = "{-# derive DataTypeable #-}\ndata Point = Point (Int,Char)\n"
