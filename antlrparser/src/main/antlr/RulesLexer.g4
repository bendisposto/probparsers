lexer grammar RulesLexer;



/*@lexer::members {
public static final int PRAGMA_MODE = 1;
}*/

import BLexer;

/*
@header {
package files;
}

options {
  tokenVocab=BLexer;
}*/


RULES_MACHINE: 'RULES_MACHINE';
RULE: 'RULE' ;
COMPUTATION: 'COMPUTATION';
FUNCTION: 'FUNCTION';

DEPENDS_ON_RULE: 'DEPENDS_ON_RULE';
DEPENDS_ON_COMPUTATION: 'DEPENDS_ON_COMPUTATION';
ERROR_TYPES: 'ERROR_TYPES';
RULEID: 'RULEID';
CLASSIFICATION: 'CLASSIFICATION';
TAGS: 'TAGS';
PRECONDITION: 'PRECONDITION';
ACTIVATION: 'ACTIVATION';

BODY: 'BODY';
IN: 'IN';
RULE_FORALL: 'RULE_FORALL';
RULE_ANY: 'RULE_ANY';
FOR: 'FOR';
EXPECT: 'EXPECT';
COUNTEREXAMPLE: 'COUNTEREXAMPLE';
ERROR_TYPE: 'ERROR_TYPE';
RULE_FAIL: 'RULE_FAIL';
DEFINE: 'DEFINE';
TYPE: 'TYPE';
DUMMY_VALUE: 'DUMMY_VALUE';
VALUE: 'VALUE';

SUCCEEDED_RULE: 'SUCCEEDED_RULE';
SUCCEEDED_RULE_ERROR_TYPE: 'SUCCEEDED_RULE_ERROR_TYPE';
FAILED_RULE: 'FAILED_RULE';
FAILED_RULE_ERROR_TYPE: 'FAILED_RULE_ERROR_TYPE';
NOT_CHECKED_RULE: 'NOT_CHECKED_RULE';
DISABLED_RULE: 'DISABLED_RULE';

STRING_FORMAT: 'STRING_FORMAT';
GET_RULE_COUNTEREXAMPLES: 'GET_RULE_COUNTEREXAMPLES';
