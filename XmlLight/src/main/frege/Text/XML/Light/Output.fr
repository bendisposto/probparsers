{--
    Output handling for the lightweight XML lib.
    
    [Module]     Text.XML.Light.Output
    [Copyright]  (c) Galois, Inc. 2007
    [License]    BSD3
    
    [Maintainer] Iavor S. Diatchki <diatchki@galois.com>
    [Stability]  provisional
-}

module Text.XML.Light.Output where

import Text.XML.Light.Types
import Data.Char hiding (isNumber)

--- The XML 1.0 header
xml_header :: String
xml_header = "<?xml version='1.0' ?>"


-- ------------------------------------------------------------------------------
abstract data ConfigPP = ConfigPP
  { shortEmptyTag :: QName -> Bool
  , prettify      :: Bool
  }

--- Default pretty printing configuration.
---  * Always use abbreviate empty tags.
defaultConfigPP :: ConfigPP
defaultConfigPP = ConfigPP.ConfigPP
                           { shortEmptyTag = const True
                           , prettify      = False
                           }

--- The predicate specifies for which empty tags we should use XML's
--- abbreviated notation <TAG />.  This is useful if we are working with
--- some XML-ish standards (such as certain versions of HTML) where some
--- empty tags should always be displayed in the <TAG></TAG> form.
useShortEmptyTags :: (QName -> Bool) -> ConfigPP -> ConfigPP
useShortEmptyTags p c = c.{ shortEmptyTag = p }


--- Specify if we should use extra white-space to make document more readable.
--- WARNING: This adds additional white-space to text elements,
--- and so it may change the meaning of the document.
useExtraWhiteSpace :: Bool -> ConfigPP -> ConfigPP
useExtraWhiteSpace p c  = c.{ prettify = p }

--- A configuration that tries to make things pretty
--- (possibly at the cost of changing the semantics a bit
--- through adding white space.)
prettyConfigPP     :: ConfigPP
prettyConfigPP      = useExtraWhiteSpace True defaultConfigPP


--------------------------------------------------------------------------------


--- Pretty printing renders XML documents faithfully,
--- with the exception that whitespace may be added\/removed
--- in non-verbatim character data.
ppTopElement       :: Element -> String
ppTopElement        = ppcTopElement prettyConfigPP

--- Pretty printing elements
ppElement          :: Element -> String
ppElement           = ppcElement prettyConfigPP

--- Pretty printing content
ppContent          :: Content -> String
ppContent           = ppcContent prettyConfigPP



--- Pretty printing renders XML documents faithfully,
--- with the exception that whitespace may be added\/removed
--- in non-verbatim character data.
ppcTopElement      :: ConfigPP -> Element -> String
ppcTopElement c e   = unlines [xml_header,ppcElement c e]

--- Pretty printing elements
ppcElement         :: ConfigPP -> Element -> String
ppcElement c e      = ppElementS c "" e ""

--- Pretty printing content
ppcContent         :: ConfigPP -> Content -> String
ppcContent c x      = ppContentS c "" x ""





--- Pretty printing content using ShowS
private ppContentS :: ConfigPP -> String -> Content -> ShowS
private ppContentS c i x xs = case x of
                        Elem e -> ppElementS c i e xs
                        Text t -> ppCDataS c i t xs
                        CRef r -> showCRefS r xs

private ppElementS :: ConfigPP -> String -> Element -> ShowS
private ppElementS c i e xs = i ++ (tagStart e.elName e.elAttribs $
  case e.elContent of
    [] | name.qName.startsWith "?" -> " ?>" ++ xs
       | c.shortEmptyTag name      -> " />" ++ xs
    [Text t] -> ">" ++ ppCDataS c "" t (tagEnd name xs)
    cs -> ">" ++ nl ++ foldr ppSub (i ++ tagEnd name xs) cs
      where ppSub e1 = ppContentS c (sp ++ i) e1 . showString nl
            (nl,sp)  = if c.prettify then ("\n","  ") else ("","")
  )
  where name = e.elName

private ppCDataS   :: ConfigPP -> String -> CData -> ShowS
private ppCDataS c i t xs   = i ++ if t.cdVerbatim /= CDataText || not c.prettify
                             then showCDataS t xs
                             else foldr cons xs $ unpacked (showCData t)

  where cons         :: Char -> String -> String
        cons '\n' ys  = "\n" ++ i ++ ys
        cons y ys     = ctos y ++ ys



-- ------------------------------------------------------------------------------

--- Adds the <?xml?> header.
showTopElement     :: Element -> String
showTopElement c    = xml_header ++ showElement c

showContent        :: Content -> String
showContent c       = ppContentS defaultConfigPP "" c ""

showElement        :: Element -> String
showElement c       = ppElementS defaultConfigPP "" c ""

showCData          :: CData -> String
showCData c         = ppCDataS defaultConfigPP "" c ""

-- Note: crefs should not contain '&', ';', etc.
private showCRefS  :: String -> ShowS
private showCRefS r xs = "&" ++ r ++ ";" ++ xs

--- Convert a text element to characters.
private showCDataS :: CData -> ShowS
private showCDataS cd =
 case cd.cdVerbatim of
   CDataText     -> escStr cd.cdData
   CDataVerbatim -> showString "<![CDATA[" . escCData cd.cdData
                                           . showString "]]>"
   CDataRaw      -> \ xs -> cd.cdData ++ xs

-- ------------------------------------------------------------------------------
private escCData   :: String -> ShowS
private escCData cs | cs.startsWith "]]>"
                    = showString "]]]]><![CDATA[>" . escCData (strtail cs 3)
private escCData "" = id
private escCData cs = showChar' (head cs) . escCData (tail cs)

private escChar    :: Char -> ShowS
private escChar c = case c of
  '<'   -> showString "&lt;"
  '>'   -> showString "&gt;"
  '&'   -> showString "&amp;"
  '"'   -> showString "&quot;"
  -- we use &#39 instead of &apos; because IE apparently has difficulties
  -- rendering &apos; in xhtml.
  -- Reported by Rohan Drape <rohan.drape@gmail.com>.
  '\''  -> showString "&#39;"

  -- NOTE: We escape '\r' explicitly because otherwise they get lost
  -- when parsed back in because of then end-of-line normalization rules.
  _ | isPrint c || c == '\n' -> showChar' c
    | otherwise -> showString "&#" . shows oc . showChar' ';'
      where oc = ord c

--- Original showChar add redundnat quotes around character (#241)
--- backported code from newer frege version
private showChar'  :: Char -> ShowS
private showChar'   = (++) . ctos

private escStr     :: String -> ShowS
private escStr cs rs = foldr escChar rs (unpacked cs)

tagEnd             :: QName -> ShowS
tagEnd qn rs        = "</" ++ showQName qn ++ ">" ++ rs

private tagStart   :: QName -> [Attr] -> ShowS
private tagStart qn as rs = "<" ++ showQName qn ++ as_str ++ rs
  where as_str       = if null as then "" else " " ++ unwords (map showAttr as)

showAttr           :: Attr -> String
showAttr (Attr qn v) = showQName qn ++ "=\"" ++ escStr v "\""

showQName          :: QName -> String
showQName q         = pre ++ q.qName
  where pre = case q.qPrefix of
                Nothing -> ""
                Just p  -> p ++ ":"
