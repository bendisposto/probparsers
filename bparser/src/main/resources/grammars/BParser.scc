Package de.be4.classicalb.core.parser;

/*******************************************************************
 * Helpers                                                         *
 *******************************************************************/

Helpers

  underscore = '_';
  double_quotation = '"';
  lf = 10;
  cr = 13;
  comment_start = '/*';
  comment_end = '*/';

  triple_quote = 39 39 39 ;
  single_quate = 39 ;

  minus = '-' | 0x2212;
  plus = '+' | 0x002b;
  gt = '>' | 0x003e;
  lt = '<' | 0x003c;
  eq = '=' | 0x003d;

  small_letter =  ['a'..'z'];
  capital_letter = ['A' .. 'Z'];
  letter = small_letter | capital_letter;

  digit = ['0' .. '9'] ;
  hexdigit = [[digit + ['a' .. 'f']] + ['A' .. 'F']] ;

  all_chars = [0 .. 0xffff];
  all_chars_without_quote = [all_chars - double_quotation];
  all_chars_without_single_quote = [all_chars - 39];

  line_break = [lf + cr];
  layout_char = [[[[0 .. 32] - line_break] + [127..160]] + [[8206 .. 8207] + [8232 .. 8233]]];
  white_space = line_break | layout_char+;
  string_literal = double_quotation  (all_chars_without_quote | '\' double_quotation)* double_quotation;
  multiline_string_literal = triple_quote (all_chars_without_single_quote| 39 all_chars_without_single_quote | 39 39 all_chars_without_single_quote  | '\' triple_quote)* triple_quote;
  identifier_literal = letter (letter | digit | underscore)*;
  pragma_identifier_literal = letter (letter | digit | underscore | minus | '.')*;

/*******************************************************************
 * States                                                          *
 *******************************************************************/

States

  section,
  normal,
  comment,
  shebang,
  pragma,
  description,
  unit;


/*******************************************************************
 * Tokens                                                          *
 *******************************************************************/

Tokens
  {section->shebang, normal -> shebang, shebang} shebang = '#!';
  {shebang -> normal} shebang_end = line_break;
  {shebang} shebang_char = all_chars;

  {section,normal} line_comment = '//' [all_chars - line_break]* line_break?;

  {section->pragma,normal->pragma} pragma_start = '/*@';
  {pragma->normal, unit->normal} pragma_end = '*/';
  {pragma->unit} pragma_unit = 'unit';
  {pragma->unit} new_pragma_unit = 'new_unit';
  {pragma->unit} ipragma_unit = 'inferred_unit';
  {pragma->unit} pragma_unit_alias = 'unit_alias';
  {pragma} pragma_generated = 'generated';
  {pragma} pragma_symbolic = 'symbolic';
  {pragma} pragma_label = 'label';
  {pragma} pragma_file = 'file';
  {pragma} pragma_package = 'package';
  {pragma} pragma_import_package = 'import-package' | 'import_package';
  {pragma->description} pragma_description = 'desc' | 'description';
  {pragma} pragma_conversion = 'conversion';
  {pragma} pragma_id_or_string = string_literal | identifier_literal | pragma_identifier_literal;
  {description} pragma_free_text = [all_chars - ['*' + '/']]*; // return to state 'normal' is done in Lexer

  {unit} unit_content = string_literal;
  {unit} unit_id = identifier_literal;

  {section->comment, normal -> comment} comment = comment_start ;
  {comment,description} comment_end = comment_end; // return to state 'normal' is done in Lexer
  {comment} comment_body = [all_chars - ['*' + '/']]*;

  {comment,description} star = '*';
  {comment,description} slash = '/';

  {normal} string_literal = string_literal | multiline_string_literal;
  {normal} for_any = '!' | 0x2200;
  {normal} exists = '#' | 0x2203;
  {normal} dollar = '$';
  {normal} lambda = '%' | 0x03bb;
  {normal} conjunction = '&' | 0x2227;
  {normal} single_quotation = 39; // single quote: '
  {normal} left_par = '(';
  {normal} right_par = ')';
  {normal} product = '*' | 0x00d7;
  {normal} power_of = '**';
  {normal} plus = plus;
  {normal} partial_function = plus minus gt | 0x21f8;
  {normal} partial_surjection = plus minus gt gt | 0x2900;
  {normal} comma = ',';
  {normal} minus = minus;
  {normal} total_function = minus minus gt | 0x2192;
  {normal} total_surjection = minus minus gt gt | 0x21a0;
  {normal} insert_start_sequence = minus gt | 0x21fe;
  {normal} dot = '.';
  {normal} interval = '..' | 0x2025;
  //{normal} dot_par = '.' white_space* '(' | 0x00b7 white_space* '(' ; // dot in generalisation expression and other expressions
  {normal} division = '/' | 0xf7;
  {normal} not_belonging = '/:' | 0x2209;
  {normal} non_inclusion = '/<:' | 0x2288;
  {normal} strict_non_inclusion = '/<<:' | 0x2284;
  {normal} not_equal = '/=' | 0x2260;
  {normal} set_subtraction = '\';
  {normal} intersection = '/\' | 0x2229;
  {normal} restrict_head_sequence = '/|\' | 0x2191;
  {normal} element_of = ':' | 0x2208;
  {normal} double_colon = '::' | ':' 0x2208;  /* becomes_element_of */
  {normal} assign = ':' eq;
  {normal} semicolon = ';';
  {normal} less = lt;
  {normal} overwrite_relation = lt plus | 0xe103 | 0x22d6; /* 0xe103 is EventB Style override, 0x22d6 is the AtelierB version */
  {normal} set_relation = lt minus gt | 0x2194;
  {normal} insert_end_sequence = '<-' | 0x21fd;
  {normal} output_parameters = '<--' | 0x2190;
  {normal} inclusion = '<:' | 0x2286;
  {normal} strict_inclusion = '<<:' | 0x2282;
  {normal} domain_subtraction = '<<|' | 0x2a64 | 0x25c0;
  {normal} less_equal = lt eq | 0x2264;
  {normal} equivalence = lt eq gt | 0x21d4;
  {normal} domain_restriction = lt '|' | 0x25c1;
  {normal} equal = eq;
  {normal} double_equal = eq eq;
  {normal} implies = eq gt | 0x21d2;
  {normal} greater = gt;
  {normal} partial_injection = gt plus gt | 0x2914;
  {normal} total_injection = gt minus gt | 0x21a3;
  {normal} partial_bijection = gt plus gt gt;
  {normal} total_bijection = gt minus gt gt | 0x2916;
  {normal} direct_product = gt lt | 0x2297;
  {normal} greater_equal = gt eq | 0x2265;
  {normal} abstract_constants = 'ABSTRACT_CONSTANTS';
  {normal} abstract_variables = 'ABSTRACT_VARIABLES';
  {normal} any = 'ANY';
  {normal} assert = 'ASSERT';
  {normal} assertions = 'ASSERTIONS';
  {normal} be = 'BE';
  {normal} begin = 'BEGIN';
  {normal} bool = 'BOOL';
  {normal} bfalse = 'bfalse';
  {normal} case = 'CASE';
  {normal} choice = 'CHOICE';
  {normal} concrete_constants = 'CONCRETE_CONSTANTS';
  {normal} concrete_variables = 'CONCRETE_VARIABLES';
  {normal} constants = 'CONSTANTS';
  {normal} constraints = 'CONSTRAINTS';
  {section->normal,normal} definitions = 'DEFINITIONS';
  {normal} do = 'DO';
  {normal} either = 'EITHER';
  {normal} else = 'ELSE';
  {normal} elsif = 'ELSIF';
  {normal} end = 'END';
  {normal} extends = 'EXTENDS';
  {normal} false = 'FALSE' | 0x22a5;
  {normal} fin = 'FIN';
  {normal} fin1 = 'FIN1';  // add 'FIN'0x8321 ?
  {normal} if = 'IF';
  {section->normal,normal} implementation = 'IMPLEMENTATION';
  {normal} imports = 'IMPORTS';
  {normal} in = 'IN';
  {normal} includes = 'INCLUDES';
  {normal} initialisation = 'INITIALISATION' | 'INITIALIZATION'; /* amerikanische Version scheinbar auch erlaubt */
  {normal} int = 'INT';
  {normal} integer = 'INTEGER' | 0x2124;
  {normal} quantified_inter = 'INTER' | 0x22c2;
  {normal} invariant = 'INVARIANT';
  {normal} let = 'LET';
  {normal} local_operations = 'LOCAL_OPERATIONS';
  {section->normal,normal} machine = 'MACHINE';
  {section->normal,normal} model = 'MODEL';
  {section->normal,normal} system = 'SYSTEM';/* SYSTEM fuer Event-B */
  {normal} max_int = 'MAXINT';
  {normal} min_int = 'MININT';
  {normal} nat = 'NAT';
  {normal} nat1 = 'NAT1';
  {normal} natural = 'NATURAL' | 0x2115;
  {normal} natural1 = 'NATURAL1' | 0x2115 0x0031 | 0x2115 0x2081;
  {normal} of = 'OF';
  {normal} operations = 'OPERATIONS' | 'EVENTS'; /* EVENTS fuer Event-B */
  {normal} or = 'OR';
  {normal} pi = 'PI' | 0x220f;
  {normal} pow = 'POW' | 0x2119;
  {normal} pow1 = 'POW1' | 0x2119 0x0031 | 0x2119 0x2081;
  {normal} pre = 'PRE';
  {normal} promotes = 'PROMOTES';
  {normal} properties = 'PROPERTIES';
  {normal} refines = 'REFINES';
  {section->normal,normal} refinement = 'REFINEMENT';
  {normal} sees = 'SEES';
  {normal} select = 'SELECT';
  {normal} sets = 'SETS';
  {normal} quantified_set = 'SET';
  {normal} sigma = 'SIGMA' | 0x2211;
  {normal} string = 'STRING';
  {normal} then = 'THEN';
  {normal} true = 'TRUE' | 0x22a4;
  {normal} quantified_union = 'UNION' | 0x22c3;
  {normal} uses = 'USES';
  {normal} value = 'VALUES';
  {normal} var = 'VAR';
  {normal} variant = 'VARIANT';
  {normal} variables = 'VARIABLES';
  {normal} when = 'WHEN';
  {normal} where = 'WHERE';
  {normal} while = 'WHILE';
  {normal} left_bracket = '[';
  {normal} right_bracket = ']';
  {normal} union = '\/' | 0x222a;
  {normal} restrict_tail_sequence = '\|/' | 0x2193;
  {normal} concat_sequence = '^' | 0x2312;
  {normal} arity = 'arity';
  {normal} bin = 'bin';
  {normal} bool_cast = 'bool';
  {normal} btree = 'btree';
  {normal} card = 'card';
  {normal} closure = 'closure';
  {normal} closure1 = 'closure1'; // add  'closure' 0x8321 ?
  {normal} conc = 'conc';
  {normal} const = 'const';
  {normal} dom = 'dom';
  {normal} father = 'father';
  {normal} first = 'first';
  {normal} fnc = 'fnc';
  {normal} front = 'front';
  {normal} id = 'id';
  {normal} infix = 'infix';
  {normal} generalized_inter = 'inter';
  {normal} iseq = 'iseq';
  {normal} iseq1 = 'iseq1'; // add 'iseq'0x8321 ?
  {normal} iterate = 'iterate';
  {normal} last = 'last';
  {normal} left = 'left';
  {normal} max = 'max';
  {normal} min = 'min';
  {normal} mirror = 'mirror';
  {normal} mod = 'mod';
  {normal} not = 'not' | 0x00ac;
  {normal} logical_or = 'or' | 0x2228;
  {normal} perm = 'perm';
  {normal} postfix = 'postfix';
  {normal} pred = 'pred';
  {normal} prefix = 'prefix';
  {normal} prj1 = 'prj1'; // add | 'iseq'0x8321 ?
  {normal} prj2 = 'prj2';
  {normal} rank = 'rank';
  {normal} ran = 'ran';
  {normal} rec = 'rec';
  {normal} rel = 'rel';
  {normal} rev = 'rev';
  {normal} right = 'right';
  {normal} seq = 'seq';
  {normal} seq1 = 'seq1'; // add | 'seq'0x8321 ?
  {normal} sizet = 'sizet';
  {normal} size = 'size';
  {normal} skip = 'skip';
  {normal} sons = 'sons';
  {normal} son = 'son';
  {normal} struct = 'struct';
  {normal} subtree = 'subtree';
  {normal} succ = 'succ';
  {normal} tail = 'tail';
  {normal} top = 'top';
  {normal} tree = 'tree';
  {normal} generalized_union = 'union';
  {normal} empty_set = 0x2205;
  {normal} left_brace = '{';
  {normal} right_brace = '}';
  {normal} vertical_bar = '|';
  {normal} double_vertical_bar = '||' | 0x2225;
  {normal} maplet = '|->' | 0x21a6;
  {normal} range_restriction = '|>' | 0x25b7;
  {normal} range_subtraction = '|>>' | 0x2a65 | 0x25b6;
  {normal} tilde = '~' | 0x223c | 0x207b 0xb9;

  // Extensions
  {normal} total_relation = lt lt minus gt | 0xe100;
  {normal} surjection_relation = lt minus gt gt | 0xe101;
  {normal} total_surjection_relation = lt lt minus gt gt | 0xe102;
  {normal} kw_freetypes = 'FREETYPES';

  // keywords for special parsing modes
  {section->normal} kw_expression = '#EXPRESSION';
  {section->normal} kw_predicate = '#PREDICATE';
  {section->normal} kw_formula = '#FORMULA';
  {section->normal} kw_substitution = '#SUBSTITUTION';
  {section->normal} kw_abstract_constants = '#ABSTRACT_CONSTANTS';
  {section->normal} kw_abstract_variables = '#ABSTRACT_VARIABLES';
  {section->normal} kw_assertions = '#ASSERTIONS';
  {section->normal} kw_concrete_constants = '#CONCRETE_CONSTANTS';
  {section->normal} kw_concrete_variables = '#CONCRETE_VARIABLES';
  {section->normal} kw_constants = '#CONSTANTS';
  {section->normal} kw_constraints = '#CONSTRAINTS';
  {section->normal} kw_definitions = '#DEFINITIONS';
  {section->normal} kw_definition = '#DEFINITION';
  {section->normal} kw_extends = '#EXTENDS';
  {section->normal} kw_imports = '#IMPORTS';
  {section->normal} kw_includes = '#INCLUDES';
  {section->normal} kw_initialisation = '#INITIALISATION';
  {section->normal} kw_invariant = '#INVARIANT';
  {section->normal} kw_local_operations = '#LOCAL_OPERATIONS';
  {section->normal} kw_operations = '#OPERATIONS';
  {section->normal} kw_promotes = '#PROMOTES';
  {section->normal} kw_properties = '#PROPERTIES';
  {section->normal} kw_sees = '#SEES';
  {section->normal} kw_sets = '#SETS';
  {section->normal} kw_uses = '#USES';
  {section->normal} kw_variables = '#VARIABLES';
  {section->normal} kw_values = '#VALUES';
  {section->normal} kw_oppattern = '#OPPATTERN';
  {section->normal} kw_machine_clause = '#MACHINECLAUSE';

  {section->normal,normal} identifier_literal = identifier_literal;
  {pragma} pragma_identifier_literal = pragma_identifier_literal;
  {normal} def_literal_substitution = '#literal_substitution' letter*;
  {normal} def_literal_predicate = '#literal_predicate' letter*;
  {normal} predicate_identifier = '#predicate_identifier' letter*;
  {normal} truth_predicate = '#truth_predicate';
  {normal} integer_literal = digit+;
  {normal} hex_literal = '0x' hexdigit+;

  {normal} underscore = underscore;

  white_space = white_space;

  // grammar extensions
  // the following tokens are never recognized by the lexer because they declared below identifier_literal
  // keywords should be synchronized with RuleGrammar.java
  {normal} kw_rules_machine = 'RULES_MACHINE';
  {normal} kw_rule = 'RULE';
  {normal} kw_substitution_operator = identifier_literal;
  {normal} kw_predicate_operator = identifier_literal;
  {normal} kw_expression_operator = identifier_literal;
  {normal} kw_predicate_attribute = identifier_literal;
  {normal} kw_attribute_identifier = identifier_literal;
  {normal} kw_for = 'FOR';
  {normal} kw_rule_for_all = 'RULE_FORALL';
  {normal} kw_rule_any = 'RULE_ANY';
  {normal} kw_rule_error_type = 'ERROR_TYPE';
  {normal} kw_expect = 'EXPECT';
  {normal} kw_computation = 'COMPUTATION';
  {normal} kw_define = 'DEFINE';
  {normal} kw_type = 'TYPE';
  {normal} kw_value = 'VALUE';
  {normal} kw_body = 'BODY';
  {normal} kw_dummy_value = 'DUMMY_VALUE';
  {normal} kw_postcondition = 'POSTCONDITION'
  {normal} kw_counterexample = 'COUNTEREXAMPLE';
  {normal} kw_function = 'FUNCTION';
  {normal} kw_references = 'REFERENCES';



/*******************************************************************
 * Ignored Tokens                                                  *
 *******************************************************************/
Ignored Tokens
shebang, shebang_char, shebang_end,
  white_space,
  comment, comment_body, comment_end, pragma_start, pragma_end, line_comment;


/*******************************************************************
 * Productions                                                     *
 *******************************************************************/
//[0,0] Production ... doesn't exist in section AST
// Such an error message indicates that a vertical bar '|' is followed by a semicolon ';'.

Productions

parse_unit {-> parse_unit} =
  {machine} P.machine {-> machine.parse_unit} |
  {definition_file} [clause]:definitions_clause {-> New parse_unit.definition_file(clause.machine_clause)} |
  {predicate} kw_predicate [pred]:predicate_top {-> New parse_unit.predicate(pred.predicate)} |
  {expression} kw_expression [expr]:expression_top {-> New parse_unit.expression(expr.expression)} |
  {predformula} kw_formula [pred]:predicate_top {-> New parse_unit.predicate(pred.predicate)} |
  {exprformula} kw_formula [expr]:expression_top {-> New parse_unit.expression(expr.expression)} |
  {substitution} kw_substitution [subst]:substitution_l1 {-> New parse_unit.substitution(subst.substitution)} |
  {oppattern} kw_oppattern [pattern]:operation_pattern {-> pattern.parse_unit} |
  {definition} kw_definition [def]:definition {-> New parse_unit.parse_unit_definition(def.definition)} |
  {machine_clause} kw_machine_clause [clause]:machine_clause {-> New parse_unit.machine_clause(clause.machine_clause)}; // used to single machine clauses

machine {-> parse_unit} =
  machine_x {-> machine_x.parse_unit} |
  {generated} pragma_generated [lower]:P.machine {-> New parse_unit.generated(lower.parse_unit)} |
  {package} pragma_package [package]:pragma_id_or_string [imports]:import_package_list? [parse_unit]:P.machine
    {-> New parse_unit.package(package, [imports.import_package], parse_unit.parse_unit)} |
  {unit_alias} pragma_unit_alias [name]:unit_id [content]:unit_content [lower]:P.machine {-> New parse_unit.unit_alias(name,content,lower.parse_unit)} ;

import_package_list {-> import_package*} =
  {single} pragma_import_package [package_or_machine]:pragma_id_or_string {-> [New import_package(package_or_machine)]} |
  {multiple} [rest]:import_package_list pragma_import_package [package_or_machine]:pragma_id_or_string {-> [rest.import_package, New import_package(package_or_machine)]} ;


machine_x {-> parse_unit} =
  {abstract} [variant]: machine_variant [header]:machine_header [machine_clauses]:machine_clause_list? end {-> New parse_unit.abstract_machine(variant, header.machine_header, [machine_clauses.machine_clause])} |
  {refinement} T.refinement [header]:machine_header refines [ref_machine]:identifier_literal [machine_clauses]:machine_clause_list? end {-> New parse_unit.refinement_machine(header.machine_header, ref_machine, [machine_clauses.machine_clause])} |
  {implementation} T.implementation [header]:machine_header refines [ref_machine]:identifier_literal [machine_clauses]:machine_clause_list? end {-> New parse_unit.implementation_machine(header.machine_header, ref_machine, [machine_clauses.machine_clause])} ;

machine_variant {-> machine_variant}
        = {machine} T.machine {-> New machine_variant.machine()}
        | {model} T.model   {-> New machine_variant.model()}
        | {system} T.system  {-> New machine_variant.system()};

machine_header {-> machine_header} =
  [name]:composed_identifier [parameters]:machine_params? {-> New machine_header([name.identifier_literal],[parameters.expression])} ;

machine_params {-> expression*} = left_par [param_list]:machine_param_list right_par {-> [param_list.expression]};

machine_param_list {-> expression*} =
  {single} [param]:machine_param {-> [param.expression]} |
  {multi} [rest]:machine_param_list comma [first]:machine_param {-> [rest.expression, first.expression]} ;

machine_param {-> expression} = [parameter]:expression_in_par {-> parameter.expression} ;

machine_clause_list {-> machine_clause*} =
  {single} [clause]:machine_clause {-> [clause.machine_clause]} |
  {multiple} [rest]:machine_clause_list [clause]:machine_clause {-> [rest.machine_clause, clause.machine_clause]} ;

machine_clause {-> machine_clause} =
  {definitions} [clause]:definitions_clause {-> clause.machine_clause} |
  {constraints} [clause]:constraints_clause {-> clause.machine_clause} |
  {sees} [clause]:sees_clause {-> clause.machine_clause} |
  {promotes} [clause]:promotes_clause {-> clause.machine_clause} |
  {uses} [clause]:uses_clause {-> clause.machine_clause} |
  {includes} [clause]:includes_clause {-> clause.machine_clause} |
  {extends} [clause]:extends_clause {-> clause.machine_clause} |
  {imports} [clause]:imports_clause {-> clause.machine_clause} |
  {sets} [clause]:sets_clause {-> clause.machine_clause} |
  {constants} [clause]:constants_clause {-> clause.machine_clause} |
  {abstract_constants} [clause]:abstract_constants_clause {-> clause.machine_clause} |
  {properties} [clause]:properties_clause {-> clause.machine_clause} |
  {concrete_variables} [clause]:concrete_variables_clause {-> clause.machine_clause} |
  {variables} [clause]:variables_clause {-> clause.machine_clause} |
  {assertions} [clause]:assertions_clause {-> clause.machine_clause} |
  {initialisation} [clause]:initialisation_clause {-> clause.machine_clause} |
  {local_operations} [clause]:local_operations_clause {-> clause.machine_clause} |
  {operations} [clause]:operations_clause {-> clause.machine_clause} |
  {values} [clause]:values_clause {-> clause.machine_clause} |
  {invariant} [clause]:invariant_clause {-> clause.machine_clause} |
  {freetypes} [clause]:freetypes_clause {-> clause.machine_clause} |
  {references} [clause]:references_clause {-> clause.machine_clause}
  ;

definitions_clause {-> machine_clause} = definitions [definition_list]:definition_list semicolon? {-> New machine_clause.definitions([definition_list.definition])} ;

definition_list {-> definition*} =
  {single} [def]:definition {-> [def.definition]} |
  {multi} [rest]:definition_list semicolon [def]:definition {-> [rest.definition, def.definition]} ;

definition {-> definition} =
  {conversion} pragma_conversion definition_x {-> New definition.conversion(definition_x.definition)} |
  definition_x {-> definition_x.definition};

definition_x {-> definition} =
  {predicate} [name]:def_literal_predicate [parameters]:def_parameters? double_equal [rhs]:predicate_top {-> New definition.predicate_definition(name, [parameters.expression], rhs.predicate)} |
  {substitution} [name]:def_literal_substitution [parameters]:def_parameters? double_equal [rhs]:substitution_l3 {-> New definition.substitution_definition(name, [parameters.expression], rhs.substitution)} |
  {expression} [name]:identifier_literal [parameters]:def_parameters? double_equal [rhs]:expression_top {-> New definition.expression_definition(name, [parameters.expression], rhs.expression)} |
  {file} [filename]:string_literal {-> New definition.file_definition(filename)};

def_parameters {-> expression*} = left_par [parameters]:identifier_list right_par {-> [parameters.expression]} ;

sees_clause {-> machine_clause} = sees [machine_names]:composed_identifier_list {-> New machine_clause.sees([machine_names.expression])} ;

references_clause {-> machine_clause} = kw_references [identifiers]:identifier_list {-> New machine_clause.references([identifiers.expression])} ;

promotes_clause {-> machine_clause} = promotes [machine_names]:composed_identifier_list {-> New machine_clause.promotes([machine_names.expression])} ;

uses_clause {-> machine_clause} = uses [machine_names]:composed_identifier_list {-> New machine_clause.uses([machine_names.expression])} ;

includes_clause {-> machine_clause} = includes [machine_references]:machine_ref_list {-> New machine_clause.includes([machine_references.machine_reference])} ;

extends_clause {-> machine_clause} = extends [machine_references]:machine_ref_list {-> New machine_clause.extends([machine_references.machine_reference])} ;

imports_clause {-> machine_clause} = imports [machine_references]:machine_ref_list {-> New machine_clause.imports([machine_references.machine_reference])} ;

machine_ref_list {-> machine_reference*} =
  {single} [ref]:machine_reference {-> [ref.machine_reference]} |
  {multi} [rest]:machine_ref_list comma [first]:machine_reference {-> [rest.machine_reference, first.machine_reference]} ;

machine_reference {-> machine_reference} =
  {simple} [machine_reference]:machine_reference2 {-> machine_reference.machine_reference} |
  {file} [machine_reference]:machine_reference2 pragma_file [file]:pragma_id_or_string
    {-> New machine_reference.file(machine_reference.machine_reference, file)} ;

machine_reference2 {-> machine_reference} =
  {simple} [machine_name]:composed_identifier [parameters]:machine_params? {-> New machine_reference([machine_name.identifier_literal], [parameters.expression])} ;

variables_clause {-> machine_clause} =
  {abstract} abstract_variables [identifiers]:identifier_list {-> New machine_clause.variables([identifiers.expression])} |
  variables [identifiers]:identifier_list {-> New machine_clause.variables([identifiers.expression])} ;

constants_clause {-> machine_clause} =
  {concrete} concrete_constants [identifiers]:identifier_list {-> New machine_clause.constants([identifiers.expression])} |
  constants [identifiers]:identifier_list {-> New machine_clause.constants([identifiers.expression])} ;

concrete_variables_clause {-> machine_clause} = concrete_variables [identifiers]:identifier_list {-> New machine_clause.concrete_variables([identifiers.expression])} ;

abstract_constants_clause {-> machine_clause} = abstract_constants [identifiers]:identifier_list {-> New machine_clause.abstract_constants([identifiers.expression])} ;

sets_clause {-> machine_clause} = sets [set_definitions]:set_def_list {-> New machine_clause.sets([set_definitions.set])};

set_def_list {-> set*} =
  {single} [set]:set {-> [set.set]} |
  {multi} [rest]:set_def_list semicolon [last]:set {-> [rest.set, last.set]} ;

set {-> set} =
  {description} [set]:set pragma_description [content]:pragma_free_text {-> New set.description(content,set)} |
  {deferred} [identifier]:composed_identifier {-> New set.deferred_set([identifier.identifier_literal])} |
  {enumerated} [identifier]:composed_identifier equal left_brace [elements]:expression_list right_brace {-> New set.enumerated_set([identifier.identifier_literal], [elements.expression])} ;

properties_clause {-> machine_clause} = properties [predicates]:predicate_top {-> New machine_clause.properties(predicates.predicate)};

initialisation_clause {-> machine_clause} = initialisation [substitutions]:substitution_l1 {-> New machine_clause.initialisation(substitutions.substitution)};

invariant_clause {-> machine_clause} = invariant [predicates]:predicate_top {-> New machine_clause.invariant(predicates.predicate)};

constraints_clause {-> machine_clause} = constraints [predicates]:predicate_top {-> New machine_clause.constraints(predicates.predicate)};

assertions_clause {-> machine_clause} = assertions [predicates]:assertions_pred_list {-> New machine_clause.assertions([predicates.predicate])};

assertions_pred_list {-> predicate*} =
  {single} [predicate]:predicate_top {-> [predicate.predicate]} |
  {multi} [rest]:assertions_pred_list semicolon [predicate]:predicate_top {-> [rest.predicate, predicate.predicate]} ;

values_clause {-> machine_clause} = value [entries]:values_entries_list {-> New machine_clause.values([entries.values_entry])} ;

values_entries_list {-> values_entry*} =
  {single} [entry]:values_entry {-> [entry.values_entry]} |
  {multi} [rest]:values_entries_list semicolon [entry]:values_entry {-> [rest.values_entry, entry.values_entry]} ;

values_entry = [identifier]:composed_identifier equal [value]:expression_top {-> New values_entry([identifier.identifier_literal], value.expression)} ;

local_operations_clause {-> machine_clause} = local_operations [operation_list]:operation_list {-> New machine_clause.local_operations([operation_list.operation])} ;

operations_clause {-> machine_clause} =
  operations [operation_list]:operation_list {-> New machine_clause.operations([operation_list.operation])} |
  {invalid_semicolon} operations [operation_list]:operation_list semicolon {-> New machine_clause.invalid_operations_clause(semicolon)} ;

operation_list {-> operation*} =
  {single} [operation]:operation {-> [operation.operation]} |
  {multi} [rest]:operation_list semicolon [operation]:operation {-> [rest.operation, operation.operation]} |
  {missing_semicolon} [rest]:operation_list [operation]:operation {-> [rest.operation, New operation.missing_semicolon(operation)]};

operation {-> operation} =
  {normal_operation} [return_values]:operation_return_values? [op_name]:composed_identifier [parameters]:op_params? equal [operation_body]:substitution_l2
    {-> New operation([return_values.expression], [op_name.identifier_literal], [parameters.expression], operation_body.substitution)} |
  {rule_operation} kw_rule [rule_name]:identifier_literal [attributes]:operation_attribute_list? kw_body [operation_body]:substitution_l0 end
    {-> New operation.rule(rule_name, [attributes.operation_attribute], operation_body.substitution)} |
  {computation} kw_computation [name]:identifier_literal [attributes]:operation_attribute_list? kw_body [body]:substitution_l0 end
    {-> New operation.computation(name, [attributes.operation_attribute], body.substitution)} |
  {function} kw_function [return_values]:operation_return_values [name]:identifier_literal [parameters]:op_params? [attributes]:operation_attribute_list? kw_body [body]:substitution_l0 end
    {-> New	 operation.function([return_values.expression], name, [parameters.expression], [attributes.operation_attribute], body.substitution)}
  ;

operation_attribute_list {-> operation_attribute*} =
  {single} [attr]:operation_attribute {-> [attr.operation_attribute]} |
  {multi} [rest]:operation_attribute_list [attr]:operation_attribute {-> [rest.operation_attribute, attr]} ;

operation_attribute {-> operation_attribute} =
  {attribute} [name]:kw_attribute_identifier [arguments]:expression_list {-> New operation_attribute(name, [arguments.expression])} |
  {predicate_attribute} [name]:kw_predicate_attribute [predicate]:predicate_top {-> New operation_attribute.predicate_attribute(name, predicate.predicate)}
  ;

operation_return_values {-> expression*} =
  [return_values]:identifier_list output_parameters {-> [return_values.expression]} ;

freetypes_clause {-> machine_clause} = kw_freetypes [freetype_list]:freetype_list {-> New machine_clause.freetypes([freetype_list.freetype])};
freetype_list {-> freetype*} =
  {single} [freetype]:freetype {-> [freetype.freetype]} |
  {multi} [rest]:freetype_list semicolon [freetype]:freetype {-> [rest.freetype, freetype.freetype]} ;
freetype {-> freetype} = [name]:identifier_literal equal [cons_list]:freetypecons_list
  {-> New freetype(name, [cons_list.freetype_constructor])};
freetypecons_list {-> freetype_constructor*} =
  {single} [constructor]:freetypecons {-> [constructor.freetype_constructor]} |
  {multi} [rest]:freetypecons_list comma [constructor]:freetypecons {-> [rest.freetype_constructor, constructor.freetype_constructor]} ;

freetypecons {-> freetype_constructor} =
  {element} [name]:identifier_literal {-> New freetype_constructor.element(name)} |
  {constructor} [name]:identifier_literal left_par [argument]:expression_in_par right_par {-> New freetype_constructor.constructor(name,argument.expression)};

/* Predicates */
predicate_top {-> predicate} = [pred]:predicate_p30 {-> pred.predicate};

predicate_p30 {-> predicate} =
  {implication} [left]:predicate_p30 implies [right]:predicate_x30 {-> New predicate.implication(left.predicate, right.predicate)} | // rechtsassoziativ?
  {next_level} [pred]:predicate_x30 {-> pred.predicate} ;
predicate_x30 {-> predicate} = [pred]:predicate_p40 {-> pred.predicate};

predicate_p40 {-> predicate} =
  {disjunct} [left]:predicate_p40 logical_or [right]:predicate_x40 {-> New predicate.disjunct(left.predicate, right.predicate)} |
  {conjunct} [left]:predicate_p40 conjunction [right]:predicate_x40 {-> New predicate.conjunct(left.predicate, right.predicate)} |
  {next_level} [pred]:predicate_x40 {-> pred.predicate};

predicate_x40 {-> predicate} =
    {label} pragma_label [name]:pragma_id_or_string [predicate]:predicate_x40 {-> New predicate.label(name,predicate.predicate)} |
    {next_level} [pred]:predicate_x41 {-> pred.predicate};

predicate_x41 {-> predicate} =
    {description} [predicate]:predicate_p60 pragma_description [content]:pragma_free_text {-> New predicate.description(content,predicate.predicate)} |
    {next_level} [pred]:predicate_x42 {-> pred.predicate};
predicate_x42 {-> predicate} = [pred]:predicate_p60 {-> pred.predicate};

predicate_p60 {-> predicate} =
  {equivalence} [left]:predicate_p60 equivalence [right]:predicate_x60 {-> New predicate.equivalence(left.predicate, right.predicate)} |
  {next_level} [pred]:predicate_x60 {-> pred.predicate};
predicate_x60 {-> predicate} = [pred]:predicate_atomic {-> pred.predicate};

/* The predicates of the following levels have completely moved down to the atomic level:
predicate_p110 {-> predicate} =
  {next_level} [pred]:predicate_x110 {-> pred.predicate};
predicate_x110 {-> predicate} = [pred]:predicate_p160 {-> pred.predicate};

predicate_p160 {-> predicate} =
  {next_level} [pred]:predicate_x160 {-> pred.predicate};
predicate_x160 {-> predicate} = [pred]:predicate_atomic {-> pred.predicate};
*/

predicate_atomic {-> predicate} =
  {subst} left_bracket [lhs_expression]:expression_list assign [rhs_expressions]:expression_list right_bracket [pred]:predicate_atomic
    {-> New predicate.substitution(New substitution.assign([lhs_expression.expression], [rhs_expressions.expression]), pred.predicate) } | //weakest precondition
    /* The following predicates have a priority in the AtelierB manual.
       But we (in contrast to AtelierB) distinguish between predicates and expression and
       can put the predicates of the form EXPR*EXPR -> PRED here.
       Thus fewer parenthesis can be used */
    /* Original priority: 60 */
  {equal} [left]:expression_top equal [right]:expression_top {-> New predicate.equal(left.expression, right.expression)} |
  {member} [left]:expression_top element_of [right]:expression_top {-> New predicate.member(left.expression, right.expression)} |
    /* Original priority: 110 */
  {subset} [left]:expression_top inclusion[right]:expression_top {-> New predicate.subset(left.expression, right.expression)} |
  {subset_strict} [left]:expression_top strict_inclusion [right]:expression_top {-> New predicate.subset_strict(left.expression, right.expression)} |
  {not_subset} [left]:expression_top non_inclusion [right]:expression_top {-> New predicate.not_subset(left.expression, right.expression)} |
  {not_subset_strict} [left]:expression_top strict_non_inclusion [right]:expression_top {-> New predicate.not_subset_strict(left.expression, right.expression)} |
    /* Original priority: 160 */
  {not_equal} [left]:expression_top not_equal [right]:expression_top {-> New predicate.not_equal(left.expression, right.expression)} |
  {not_member} [left]:expression_top not_belonging [right]:expression_top {-> New predicate.not_member(left.expression, right.expression)} |
  {less_equal} [left]:expression_top less_equal [right]:expression_top {-> New predicate.less_equal(left.expression, right.expression)} |
  {less} [left]:expression_top less [right]:expression_top {-> New predicate.less(left.expression, right.expression)} |
  {greater_equal} [left]:expression_top greater_equal [right]:expression_top {-> New predicate.greater_equal(left.expression, right.expression)} |
  {greater} [left]:expression_top greater [right]:expression_top {-> New predicate.greater(left.expression, right.expression)} |

  /* Now we continue with the real atomic predicates: */
  {bfalse} bfalse {-> New predicate.falsity()} |
  {truth_predicate} truth_predicate {-> New predicate.truth()} |
  {bracketed} left_par [predicate]:predicate_top right_par {-> predicate.predicate} |
  {negation} not left_par [predicate]:predicate_top right_par {-> New predicate.negation(predicate.predicate)} |
  {forall} for_any [identifiers]:quantified_variables_list dot left_par [implication]:predicate_top right_par {-> New predicate.forall([identifiers.expression], implication.predicate)} | // check in typechecker: predicate must be an implication predicate
  {exists} exists [identifiers]:quantified_variables_list dot left_par [predicate]:predicate_top right_par {-> New predicate.exists([identifiers.expression], predicate.predicate)} |
  {definition} [def_literal]:def_literal_predicate [parameters]:def_call_params? {-> New predicate.definition(def_literal, [parameters.expression])} |
  {identifier} [literal]:predicate_identifier {-> New predicate.predicate_identifier(literal)} |
  {function} [literal]:predicate_identifier  left_par [parameters]:expression_list right_par {-> New predicate.predicate_function(literal, [parameters.expression])} |
  {if_predicate} if [condition]:predicate_top then [then_pred]:predicate_top else [else_pred]:predicate_top end
    {-> New predicate.if_predicate(condition.predicate, then_pred.predicate, else_pred.predicate)} |
  {let_predicate} let [identifiers]:identifier_list be [definition]:predicate_top in [pred]:predicate_top end
    {-> New predicate.let_predicate([identifiers.expression], definition.predicate, pred.predicate)} |
  {predicate_operator} [name]:kw_predicate_operator [parameters]:op_params {-> New predicate.operator(name,[parameters.expression])}  // extension
  ;

/* Expressions */

/* expression_in_par contains the priority level 20, it is not considered as expression_top
   because ; and || should only be used inside parentheses */
expression_in_par {-> expression} =
  {composition} [left]:expression_in_par semicolon [right]:expression_top {-> New expression.composition(left.expression, right.expression)} |
  {parallel_product} [left]:expression_in_par double_vertical_bar [right]:expression_top {-> New expression.parallel_product(left.expression, right.expression)} |
  {next_level} [expr]:expression_top {-> expr.expression};

expression_top {-> expression} = [expr]:expression_p125 {-> expr.expression};

/*expression_p20 {-> expression} =
  {parallel_product} left_par [left]:expression_p20 double_vertical_bar [right]:expression_x20 right_par {-> New expression.parallel_product(left.expression, right.expression)} | // zu sehr eingeschraenkt?!?
  {next_level} [expr]:expression_x20 {-> expr.expression} ;
expression_x20 {-> expression} = [expr]:expression_p125 {-> expr.expression}; */

expression_p125 {-> expression} =
  {relations} [left]:expression_p125 set_relation [right]:expression_x125 {-> New expression.relations(left.expression, right.expression)} |
  {partial_function} [left]:expression_p125 partial_function [right]:expression_x125 {-> New expression.partial_function(left.expression, right.expression)} |
  {total_function} [left]:expression_p125 total_function [right]:expression_x125 {-> New expression.total_function(left.expression, right.expression)} |
  {partial_injection} [left]:expression_p125 partial_injection [right]:expression_x125 {-> New expression.partial_injection(left.expression, right.expression)} |
  {total_injection} [left]:expression_p125 total_injection [right]:expression_x125 {-> New expression.total_injection(left.expression, right.expression)} |
  {partial_surjection} [left]:expression_p125 partial_surjection [right]:expression_x125 {-> New expression.partial_surjection(left.expression, right.expression)} |
  {total_surjection} [left]:expression_p125 total_surjection [right]:expression_x125 {-> New expression.total_surjection(left.expression, right.expression)} |
  {partial_bijection} [left]:expression_p125 partial_bijection [right]:expression_x125 {-> New expression.partial_bijection(left.expression, right.expression)} |
  {total_bijection} [left]:expression_p125 total_bijection [right]:expression_x125 {-> New expression.total_bijection(left.expression, right.expression)} |
  {total_relation} [left]:expression_p125 total_relation [right]:expression_x125 {-> New expression.total_relation(left.expression, right.expression)} |
  {surjection_relation} [left]:expression_p125 surjection_relation [right]:expression_x125 {-> New expression.surjection_relation(left.expression, right.expression)} |
  {total_surjection_relation} [left]:expression_p125 total_surjection_relation [right]:expression_x125 {-> New expression.total_surjection_relation(left.expression, right.expression)} |
  {next_level} [expr]:expression_x125 {-> expr.expression} ;
expression_x125 {-> expression} = [expr]:expression_p160 {-> expr.expression};

expression_p160 {-> expression} =
  {overwrite} [left]:expression_p160 overwrite_relation [right]:expression_x160 {-> New expression.overwrite(left.expression, right.expression)} |
  {direct_product} [left]:expression_p160 direct_product [right]:expression_x160 {-> New expression.direct_product(left.expression, right.expression)} |
  {concat} [left]:expression_p160 concat_sequence [right]:expression_x160 {-> New expression.concat(left.expression, right.expression)} |
  {domain_restriction} [left]:expression_p160 domain_restriction [right]:expression_x160 {-> New expression.domain_restriction(left.expression, right.expression)} |
  {domain_subtraction} [left]:expression_p160 domain_subtraction [right]:expression_x160 {-> New expression.domain_subtraction(left.expression, right.expression)} |
  {range_restriction} [left]:expression_p160 range_restriction [right]:expression_x160 {-> New expression.range_restriction(left.expression, right.expression)} |
  {range_subtraction} [left]:expression_p160 range_subtraction [right]:expression_x160 {-> New expression.range_subtraction(left.expression, right.expression)} |
  {insert_front} [left]:expression_p160 insert_start_sequence [right]:expression_x160 {-> New expression.insert_front(left.expression, right.expression)} |
  {insert_tail} [left]:expression_p160 insert_end_sequence [right]:expression_x160 {-> New expression.insert_tail(left.expression, right.expression)} |
  {union} [left]:expression_p160 union [right]:expression_x160 {-> New expression.union(left.expression, right.expression)} |
  {intersection} [left]:expression_p160 intersection [right]:expression_x160 {-> New expression.intersection(left.expression, right.expression)} |
  {restrict_front} [left]:expression_p160 restrict_head_sequence [right]:expression_x160 {-> New expression.restrict_front(left.expression, right.expression)} |
  {restrict_tail} [left]:expression_p160 restrict_tail_sequence [right]:expression_x160 {-> New expression.restrict_tail(left.expression, right.expression)} |
  {couple1} [left]:expression_p160 maplet [right]:expression_x160 {-> New expression.couple([left.expression, right.expression])} |
  {next_level} [expr]:expression_x160 {-> expr.expression} ;
expression_x160 {-> expression} = [expr]:expression_p170 {-> expr.expression};

expression_p170 {-> expression} =
  {interval} [left_border]:expression_p170 interval [right_border]:expression_x170 {-> New expression.interval(left_border.expression, right_border.expression)} |
  {next_level} [expr]:expression_x170 {-> expr.expression} ;
expression_x170 {-> expression} = [expr]:expression_p180 {-> expr.expression};

expression_p180 {-> expression} =
  {minus_or_set_subtract} [left]:expression_p180 minus [right]:expression_x180 {-> New expression.minus_or_set_subtract(left.expression, right.expression)} |
  {add} [left]:expression_p180 plus [right]:expression_x180 {-> New expression.add(left.expression, right.expression)} |
  {set_subtraction} [left]:expression_p180 set_subtraction [right]:expression_x180 {-> New expression.set_subtraction(left.expression, right.expression)} |
  {next_level} [expr]:expression_x180 {-> expr.expression} ;
expression_x180 {-> expression} = [expr]:expression_p190 {-> expr.expression};

expression_p190 {-> expression} =
  {mul} [left]:expression_p190 product [right]:expression_x190 {-> New expression.mult_or_cart(left.expression, right.expression)} |
  {div} [left]:expression_p190 division [right]:expression_x190 {-> New expression.div(left.expression, right.expression)} |
  {modulo} [left]:expression_p190 mod [right]:expression_x190 {-> New expression.modulo(left.expression, right.expression)} |
  {next_level} [expr]:expression_x190 {-> expr.expression} ;
expression_x190 {-> expression} = [expr]:expression_p200 {-> expr.expression};

/* Attention: power_of is right-assoziative! */
expression_p200 {-> expression} =
  {power_of} [left]:expression_x200 power_of [right]:expression_p200 {-> New expression.power_of(left.expression, right.expression)} |  // right associative!
  {next_level} [expr]:expression_x200 {-> expr.expression} ;
expression_x200 {-> expression} = [expr]:expression_p210 {-> expr.expression};

expression_p210 {-> expression} =
  {unary_minus} minus [expression]:expression_x210 {-> New expression.unary_minus(expression.expression)} |
  {next_level} [expr]:expression_x210 {-> expr.expression} ;
expression_x210 {-> expression} = [expr]:expression_p230 {-> expr.expression};

expression_p230 {-> expression} =
  {reverse} [expression]:expression_x230 tilde {-> New expression.reverse(expression.expression)} |
  {next_level} [expr]:expression_x230 {-> expr.expression} ;
expression_x230 {-> expression} = [expr]:expression_p231 {-> expr.expression};

expression_p231 {-> expression} =
  {image} [left]:expression_p230 left_bracket [right]:expression_in_par right_bracket {-> New expression.image(left.expression, right.expression)} |
  {next_level} [expr]:expression_x231 {-> expr.expression} ;
expression_x231 {-> expression} = [expr]:expression_keyword {-> expr.expression};

expression_keyword {-> expression} =
  {convert_bool} bool_cast left_par [predicate]:predicate_top right_par {-> New expression.convert_bool(predicate.predicate)} |
  {max} max left_par [expression]:expression_in_par right_par {-> New expression.max(expression.expression)} |
  {min} min left_par [expression]:expression_in_par right_par {-> New expression.min(expression.expression)} |
  {card} card left_par [expression]:expression_in_par right_par {-> New expression.card(expression.expression)} |
  {general_sum} sigma [identifiers]:quantified_variables_list dot left_par [predicates]:predicate_top vertical_bar [expression]:expression_in_par right_par {-> New expression.general_sum([identifiers.expression], predicates.predicate, expression.expression)} |
  {general_product} pi [identifiers]:quantified_variables_list dot left_par [predicates]:predicate_top vertical_bar [expression]:expression_in_par right_par {-> New expression.general_product([identifiers.expression], predicates.predicate, expression.expression)} |
  {pow_subset} pow left_par [expression]:expression_in_par right_par {-> New expression.pow_subset(expression.expression)} |
  {pow1_subset} pow1 left_par [expression]:expression_in_par right_par {-> New expression.pow1_subset(expression.expression)} |
  {fin_subset} fin left_par [expression]:expression_in_par right_par {-> New expression.fin_subset(expression.expression)} |
  {fin1_subset} fin1 left_par [expression]:expression_in_par right_par {-> New expression.fin1_subset(expression.expression)} |
  {general_union} generalized_union left_par [expression]:expression_in_par right_par {-> New expression.general_union(expression.expression)} |
  {general_intersection} generalized_inter left_par [expression]:expression_in_par right_par {-> New expression.general_intersection(expression.expression)} |
  {identity} id left_par [expression]:expression_in_par right_par {-> New expression.identity(expression.expression)} |
  {reflexive_closure} closure left_par [expression]:expression_in_par right_par {-> New expression.reflexive_closure(expression.expression)} |
  {closure} closure1 left_par [expression]:expression_in_par right_par {-> New expression.closure(expression.expression)} |
  {domain} dom left_par [expression]:expression_in_par right_par {-> New expression.domain(expression.expression)} |
  {range} ran left_par [expression]:expression_in_par right_par {-> New expression.range(expression.expression)} |
  {lambda} lambda [identifiers]:quantified_variables_list dot left_par [predicate]:predicate_top vertical_bar [expression]:expression_in_par right_par
    {-> New expression.lambda([identifiers.expression], predicate.predicate, expression.expression)} |
  {symbolic_lambda} pragma_symbolic lambda [identifiers]:quantified_variables_list dot left_par [predicate]:predicate_top vertical_bar [expression]:expression_in_par right_par
    {-> New expression.symbolic_lambda([identifiers.expression], predicate.predicate, expression.expression)} |
  {trans_function} fnc left_par [expression]:expression_in_par right_par {-> New expression.trans_function(expression.expression)} |
  {trans_relation} rel left_par [expression]:expression_in_par right_par {-> New expression.trans_relation(expression.expression)} |
  {seq} seq left_par [expression]:expression_in_par right_par {-> New expression.seq(expression.expression)} |
  {seq1} seq1 left_par [expression]:expression_in_par right_par {-> New expression.seq1(expression.expression)} |
  {iseq} iseq left_par [expression]:expression_in_par right_par {-> New expression.iseq(expression.expression)} |
  {iseq1} iseq1 left_par [expression]:expression_in_par right_par {-> New expression.iseq1(expression.expression)} |
  {perm} perm left_par [expression]:expression_in_par right_par {-> New expression.perm(expression.expression)} |
  {empty_sequence1} left_bracket right_bracket {-> New expression.empty_sequence()} |
  {empty_sequence2} less greater {-> New expression.empty_sequence()} |
  {size} size left_par [expression]:expression_in_par right_par {-> New expression.size(expression.expression)} |
  {first} first left_par [expression]:expression_in_par right_par {-> New expression.first(expression.expression)} |
  {last} last left_par [expression]:expression_in_par right_par {-> New expression.last(expression.expression)} |
  {front} front left_par [expression]:expression_in_par right_par {-> New expression.front(expression.expression)} |
  {tail} tail left_par [expression]:expression_in_par right_par {-> New expression.tail(expression.expression)} |
  {rev} rev left_par [expression]:expression_in_par right_par {-> New expression.rev(expression.expression)} |
  {first_projection} prj1 left_par [exp1]:expression_in_par comma [exp2]:expression_in_par right_par {-> New expression.first_projection(exp1.expression, exp2.expression)} |
  {second_projection} prj2 left_par [exp1]:expression_in_par comma [exp2]:expression_in_par right_par {-> New expression.second_projection(exp1.expression, exp2.expression)} |
  {iteration} iterate left_par [left]:expression_in_par comma [right]:expression_in_par right_par {-> New expression.iteration(left.expression, right.expression)} |
  {comprehension_set} left_brace [identifiers]:expression_list vertical_bar [predicates]:predicate_top right_brace {-> New expression.comprehension_set([identifiers.expression], predicates.predicate)}  |
  {symbolic_comprehension_set} pragma_symbolic left_brace [identifiers]:expression_list vertical_bar [predicates]:predicate_top right_brace {-> New expression.symbolic_comprehension_set([identifiers.expression], predicates.predicate)}  |
  {quantified_union} quantified_union [identifiers]:quantified_variables_list dot left_par [predicates]:predicate_top vertical_bar [expression]:expression_in_par right_par {-> New expression.quantified_union([identifiers.expression], predicates.predicate, expression.expression)} |
  {quantified_intersection} quantified_inter [identifiers]:quantified_variables_list dot left_par [predicates]:predicate_top vertical_bar [expression]:expression_in_par right_par {-> New expression.quantified_intersection([identifiers.expression], predicates.predicate, expression.expression)} |
  {quantified_set} quantified_set [identifiers]:quantified_variables_list dot left_par [predicates]:predicate_top right_par {-> New expression.prover_comprehension_set([identifiers.expression], predicates.predicate)}  |
  {set_extension} left_brace [expressions]:expression_list right_brace {-> New expression.set_extension([expressions.expression])} |
  {sequence_extension} left_bracket [expressions]:expression_list right_bracket {-> New expression.sequence_extension([expressions.expression])} |
  {couple2} left_par [first]:expression_in_par comma [rest]:expression_list right_par {-> New expression.couple([first.expression, rest.expression])} | // Klammern notwendig
  {general_concat} conc left_par [expression]:expression_in_par right_par {-> New expression.general_concat(expression.expression)} |
  {tree} tree left_par [expression]:expression_in_par right_par {-> New expression.tree(expression.expression)} |
  {btree} btree left_par [expression]:expression_in_par right_par {-> New expression.btree(expression.expression)} |
  {const} const left_par [expr1]:expression_in_par comma [expr2]:expression_in_par right_par {-> New expression.const(expr1.expression, expr2.expression)} |
  {top} top left_par [expression]:expression_in_par right_par {-> New expression.top(expression.expression)} |
  {sons} sons left_par [expression]:expression_in_par right_par {-> New expression.sons(expression.expression)} |
  {prefix} prefix left_par [expression]:expression_in_par right_par {-> New expression.prefix(expression.expression)} |
  {postfix} postfix left_par [expression]:expression_in_par right_par {-> New expression.postfix(expression.expression)} |
  {sizet} sizet left_par [expression]:expression_in_par right_par {-> New expression.sizet(expression.expression)} |
  {mirror} mirror left_par [expression]:expression_in_par right_par {-> New expression.mirror(expression.expression)} |
  {rank} rank left_par [expression1]:expression_in_par comma [expression2]:expression_in_par right_par {-> New expression.rank(expression1.expression, expression2.expression)} |
  {father} father left_par [expression1]:expression_in_par comma [expression2]:expression_in_par right_par {-> New expression.father(expression1.expression, expression2.expression)} |
  {son} son left_par [expression1]:expression_in_par [comma1]:comma [expression2]:expression_in_par [comma2]:comma [expression3]:expression_in_par right_par {-> New expression.son(expression1.expression, expression2.expression, expression3.expression)} |
  {subtree} subtree left_par [expression1]:expression_in_par comma [expression2]:expression_in_par right_par {-> New expression.subtree(expression1.expression, expression2.expression)} |
  {arity} arity left_par [expression1]:expression_in_par comma [expression2]:expression_in_par right_par {-> New expression.arity(expression1.expression, expression2.expression)} |
  {bin1} bin left_par [expression]:expression_in_par right_par {-> New expression.bin(expression.expression, Null, Null)} |
  {bin2} bin left_par [expression1]:expression_in_par [comma1]:comma [expression2]:expression_in_par [comma2]:comma [expression3]:expression_in_par right_par {-> New expression.bin(expression1.expression, expression2.expression, expression3.expression)} |
  {left} left left_par [expression]:expression_in_par right_par {-> New expression.left(expression.expression)} |
  {right} right left_par [expression]:expression_in_par right_par {-> New expression.right(expression.expression)} |
  {infix} infix left_par [expression]:expression_in_par right_par {-> New expression.infix(expression.expression)} |
  {struct} struct left_par [entries]:rec_entry_list right_par {-> New expression.struct([entries.rec_entry])} |
  {rec} rec left_par [entries]:rec_entry_list right_par {-> New expression.rec([entries.rec_entry])} |
  {record_field} [record]:expression_p231 single_quotation [identifier]:expression_atomic {-> New expression.record_field(record.expression, identifier.expression)} |
  {expression_operator} [name]:kw_expression_operator [parameters]:op_params {-> New expression.operator(name, [parameters.expression])} | // extension
  {next_level} [expr]:expression_func {-> expr.expression} ;

rec_entry {-> rec_entry} =
  {in_pars} left_par [identifier]:expression_top element_of [value]:expression_in_par right_par {-> New rec_entry(identifier.expression, value.expression)} |
  {no_pars} [identifier]:expression_top element_of [value]:expression_in_par {-> New rec_entry(identifier.expression, value.expression)};

rec_entry_list {-> rec_entry*} =
  {single} [entry]:rec_entry {-> [entry.rec_entry]} |
  {multi} [rest]:rec_entry_list comma [last]:rec_entry {-> [rest.rec_entry, last.rec_entry]};

expression_func {-> expression} =
  {function} [function]:expression_p230 left_par [parameters]:expression_list right_par {-> New expression.function(function.expression, [parameters.expression])} |
  {next_level} expression_atomic {-> expression_atomic.expression} ;

expression_atomic {-> expression} =
  {paren} left_par [expression]:expression_in_par right_par {-> expression.expression} |
  {identifier} [identifier]:composed_identifier {-> New expression.identifier([identifier.identifier_literal])} |
  {primed_identifier} [identifier]:composed_identifier dollar [grade]:integer_literal {-> New expression.primed_identifier([identifier.identifier_literal], grade)} |
  {string} [content]:string_literal {-> New expression.string(content)} |
  {boolean_true} true {-> New expression.boolean_true()} |
  {boolean_false} false {-> New expression.boolean_false()} |
  {successor} succ {-> New expression.successor()} |
  {predecessor} pred {-> New expression.predecessor()} |
  {integer} [literal]:integer_literal {-> New expression.integer(literal)} |
  {max_int} max_int {-> New expression.max_int()} |
  {min_int} min_int {-> New expression.min_int()} |
  {empty_set_symbol} empty_set {-> New expression.empty_set()} |
  {empty_set} left_brace right_brace {-> New expression.empty_set()} |
  {integer_set} integer {-> New expression.integer_set()} |
  {natural_set} natural {-> New expression.natural_set()} |
  {natural1_set} natural1 {-> New expression.natural1_set()} |
  {nat_set} nat {-> New expression.nat_set()} |
  {nat1_set} nat1 {-> New expression.nat1_set()} |
  {int_set} int {-> New expression.int_set()} |
  {bool_set} bool {-> New expression.bool_set()} |
  {if_expression} if [condition]:predicate_top then [then_expr]:expression_top else [else_expr]:expression_top end
    {-> New expression.if_then_else(condition.predicate, then_expr.expression, else_expr.expression)} |
  {let_expression} let [identifiers]:identifier_list be [definition]:predicate_top in [expr]:expression_top end
    {-> New expression.let_expression([identifiers.expression], definition.predicate, expr.expression)} |
  {string_set} string {-> New expression.string_set()} ;

expression_list {-> expression*} =
  {single} [expression]:expression_top {-> [expression.expression]} |
  {multiple} [rest]:expression_list comma [last]:expression_top {-> [rest.expression, last.expression]} ;

/*expression_list_in_par {-> expression*} =
  {single} [expression]:expression_in_par {-> [expression.expression]} |
  {multiple} [rest]:expression_list_in_par comma [last]:expression_in_par {-> [rest.expression, last.expression]} ;
*/


/* Substitutions */

substitution_l0 {-> substitution} =
  {invalid} substitution_l2 semicolon {-> New substitution.invalid(semicolon)} |
  {next_level} substitution_l1 {-> substitution_l1.substitution} ;

substitution_l1 {-> substitution} =
  {sequence} [first]:substitution_l2 semicolon [second]:substitution_l2 [rest]:sequence_subst_tail? {-> New substitution.sequence([first.substitution, second.substitution, rest.substitution])} |
  {next_level} [sub]:substitution_l2 {-> sub.substitution} ;

sequence_subst_tail {-> substitution*} =
  {single} semicolon [substitution]:substitution_l2 {-> [substitution.substitution]} |
  {multi} semicolon [substitution]:substitution_l2 [rest]:sequence_subst_tail {-> [substitution.substitution, rest.substitution]} |
  {invalid} semicolon {-> [New substitution.invalid(semicolon)]} ;

substitution_l2 {-> substitution} =
  {parallel} [first]:substitution_l3 double_vertical_bar [second]:substitution_l3 [rest]:parallel_subst_tail? {-> New substitution.parallel([first.substitution, second.substitution, rest.substitution])} |
  {next_level} [sub]:substitution_l3 {-> sub.substitution} ;

parallel_subst_tail {-> substitution*} =
  {single} double_vertical_bar [substitution]:substitution_l3 {-> [substitution.substitution]} |
  {multi} double_vertical_bar [substitution]:substitution_l3 [rest]:parallel_subst_tail {-> [substitution.substitution, rest.substitution]} ;

substitution_l3 {-> substitution} =
  {block} begin [substitution]:substitution_l0 end {-> New substitution.block(substitution.substitution)} |
  {skip} skip {-> New substitution.skip()} |
  {assign} [lhs_expression]:assign_list assign [rhs_expressions]:expression_list {-> New substitution.assign([lhs_expression.expression], [rhs_expressions.expression])} |
  {precondition} pre [predicate]:predicate_top then [substitution]:substitution_l0 end {-> New substitution.precondition(predicate.predicate, substitution.substitution)} |
  {assertion} assert [predicate]:predicate_top then [substitution]:substitution_l0 end {-> New substitution.assertion(predicate.predicate, substitution.substitution)} |
  {choice} choice [first]:substitution_l0 [rest]:choice_or* end {-> New substitution.choice([first.substitution, rest.substitution])} |
  {if} if [condition]:predicate_top then [then_subst]:substitution_l0 [elsifs]:if_elsif* [else]:if_else? end {-> New substitution.if(condition.predicate, then_subst.substitution, [elsifs.substitution], else.substitution)} |
  {select} select [condition]:predicate_top then [then_subst]:substitution_l0 [whens]:select_when* [else]:select_else? end {-> New substitution.select(condition.predicate, then_subst.substitution, [whens.substitution], else.substitution)} |
  {case} case [case_expr]:expression_in_par of either [either_expr]:expression_list then [either_subst]:substitution_l0 [or_substitutions]:case_or* [else]:case_else? [end1]:end [end2]:end {-> New substitution.case(case_expr.expression, [either_expr.expression],  either_subst.substitution, [or_substitutions.substitution], else.substitution)} |
  {any} any [identifiers]:identifier_list where [where_pred]:predicate_top then [then_subst]:substitution_l0 end {-> New substitution.any([identifiers.expression], where_pred.predicate, then_subst.substitution)} |
  {becomes_element_of} [identifiers]:assign_list double_colon [set]:expression_top {-> New substitution.becomes_element_of([identifiers.expression], set.expression)} |
  {becomes_such} [identifiers]:assign_list element_of left_par [predicate]:predicate_top right_par {-> New substitution.becomes_such([identifiers.expression], predicate.predicate)} |
  {var} var [identifiers]:identifier_list in [substitution]:substitution_l0 end {-> New substitution.var([identifiers.expression], substitution.substitution)} |
  //{func_op} [expr]:expression_func {-> New substitution.func_op(expr.expression)} | // (old) check in semantic check if expression is a function
  {operation_call_without_parameter} [op]:identifier_or_function {-> New substitution.func_op(op.expression)} | // check in semantic check if expression is a function
  {operation_call} [return_values]:assign_list output_parameters [op_name]:composed_identifier [parameters]:op_params? {-> New substitution.operation_call([return_values.expression], [op_name.identifier_literal], [parameters.expression])} |
  {while} while [condition]:predicate_top do [do_subst]:substitution_l0 invariant [invariant_pred]:predicate_top variant [variant_expr]:expression_in_par end {-> New substitution.while(condition.predicate, do_subst.substitution, invariant_pred.predicate, variant_expr.expression)} |
  {let} let [identifiers]:identifier_list be [predicate]:predicate_top in [substitution]:substitution_l0 end {-> New substitution.let([identifiers.expression], predicate.predicate, substitution.substitution)} |
  {definition} [def_literal]:def_literal_substitution [parameters]:def_call_params? {-> New substitution.definition(def_literal, [parameters.expression])} |

    // extensions for rules
  {for_loop} kw_for [identifier]:identifier_declaration_expression in [set]:expression_in_par do [do_subst]:substitution_l0 end
    {-> New substitution.for_loop(identifier.expression, set.expression, do_subst.substitution)} |
  {forall_sub_message} kw_rule_for_all [identifiers]:identifier_list where [where_pred]:predicate_top kw_expect [expect_pred]:predicate_top [error_type]:error_type? kw_counterexample [message]:expression_top end
    {-> New substitution.forall_sub_message([identifiers.expression], where_pred.predicate, expect_pred.predicate, error_type.integer_literal, message.expression)} |
  {rule_any_message_sub} kw_rule_any [identifiers]:identifier_list where [where_pred]:predicate_top [error_type]:error_type? kw_counterexample [message]:expression_top end
    {-> New substitution.rule_any_sub_message([identifiers.expression], where_pred.predicate, error_type.integer_literal, message.expression)} |
  {substitution_operator} [name]:kw_substitution_operator [arguments]:op_params? {-> New substitution.operator(name, [arguments.expression])} |
  {define} kw_define [name]:identifier_literal kw_type [type]:expression_in_par [dummy]:dummy_value? kw_value [value]:expression_in_par end
  	{-> New substitution.define(name, type.expression, dummy.expression, value.expression)}
  ;
message {-> expression} = left_par [expr]:expression_in_par right_par {-> expr.expression};
dummy_value {-> expression} = kw_dummy_value [expr]:expression_in_par {-> expr.expression};
error_type {-> integer_literal} = kw_rule_error_type [id]:integer_literal {-> id };

choice_or {-> substitution} =
  or [substitution]:substitution_l0 {-> New substitution.choice_or(substitution.substitution)} ;

if_elsif {-> substitution} =
  elsif [condition]:predicate_top then [subst]:substitution_l0 {-> New substitution.if_elsif(condition.predicate, subst.substitution)};

if_else {-> substitution} =
  else [subst]:substitution_l0 {-> subst.substitution};

select_when {-> substitution} =
  when [condition]:predicate_top then [subst]:substitution_l0 {-> New substitution.select_when(condition.predicate, subst.substitution)};

select_else {-> substitution} =
  else [subst]:substitution_l0 {-> subst.substitution};

case_or {-> substitution} =
  or [expressions]:expression_list then [subst]:substitution_l0 {-> New substitution.case_or([expressions.expression], subst.substitution)};

case_else {-> substitution} =
  else [subst]:substitution_l0 {-> subst.substitution};

op_params {-> expression*} =
  left_par [parameters]:expression_list right_par {-> [parameters.expression]} ;


/* Basics */
composed_identifier {-> identifier_literal*} =
  {single} [name]:identifier_literal {-> [name]} |
  {multi} [rest]:composed_identifier dot [first]:identifier_literal {-> [rest.identifier_literal, first]} ;

composed_identifier_list {-> expression*} =
  {single} [identifier]:composed_identifier_file_pragma_expression {-> [identifier.expression]} |
  {multi} [rest]:composed_identifier_list comma [identifier]:composed_identifier_file_pragma_expression {-> [rest.expression, identifier.expression]} ;

composed_identifier_file_pragma_expression {-> expression} =
  {normal}[identifier]:composed_identifier_expression {-> identifier.expression } |
  {file} [identifier]:composed_identifier_expression pragma_file [file]:pragma_id_or_string {-> New expression.file(identifier.expression, file)} ;

composed_identifier_expression {-> expression} =
  {normal}[identifier]:composed_identifier {-> New expression.identifier([identifier.identifier_literal])} ;

identifier_list {-> expression*} =
  {single} [identifier]:identifier_declaration_expression {-> [identifier.expression]} |
  {multi} [rest]:identifier_list comma [identifier]:identifier_declaration_expression {-> [rest.expression, identifier.expression]} ;

/* a,b,f(1),g(1)(2) := ... */
assign_list {-> expression*} =
  {single} [name]:identifier_or_function {-> [name.expression]} |
  {multi} [rest]:assign_list comma [name]:identifier_or_function {-> [rest.expression, name.expression]} ;

identifier_or_function {-> expression} =
   {single} [name]:composed_identifier_expression {-> name.expression} |
   {function} [name]:identifier_or_function [parameters]:op_params {-> New expression.function(name.expression, [parameters.expression])};

normal_identifier_expression {-> expression} =
  {identifier} [identifier]:identifier_literal {-> New expression.identifier([identifier])} ;

quantified_variables_list {-> expression*} =
  {parentheses} left_par [id]:identifier_list right_par {-> [id.expression]} |
  {no_parentheses} [id]:identifier_list {-> [id.expression]};

/*
Avoid the following transformation rule which would yield to an AIdentifierNode without a position information. Include an indirection!
{unit} pragma_unit [content]:unit_content [identifier]:identifier_literal {-> New expression.unit(content,New expression.identifier([identifier]))}
*/
identifier_declaration_expression {-> expression} =
  {description} [identifier]:identifier_expression pragma_description [content]:pragma_free_text {-> New expression.description(content,identifier.expression)}|
  {unit} pragma_unit [content]:unit_content [identifier]:identifier_expression {-> New expression.unit(content,identifier.expression)} |
  {new_unit} new_pragma_unit [content]:unit_content [identifier]:identifier_expression {-> New expression.new_unit(content,identifier.expression)} |
  {inferred_unit} ipragma_unit [content]:unit_content [identifier]:identifier_expression {-> New expression.inferredunit(content,identifier.expression)} |
  {identifier} [identifier]:identifier_literal {-> New expression.identifier([identifier])} ;


identifier_expression {-> expression} =
  {identifier} [identifier]:identifier_literal {-> New expression.identifier([identifier])} ;

def_call_params {-> expression*} = left_par [params]:expression_list right_par {-> [params.expression]} ;


/* Patterns for opertions */
operation_pattern {-> parse_unit }=
  [op_name]:composed_identifier [parameters]:op_pattern_params? {-> New parse_unit.oppattern([op_name.identifier_literal], [parameters.argpattern])} ;

op_pattern_params {-> argpattern*} =
  left_par [parameters]:oppattern_list right_par {-> [parameters.argpattern]} ;
oppattern_list {-> argpattern*} =
  {single} [arg]:op_pattern_param {-> [arg.argpattern]} |
  {multiple} [rest]:oppattern_list comma [last]:op_pattern_param {-> [rest.argpattern, last.argpattern]} ;
op_pattern_param {-> argpattern} =
    {def}   [expression]:expression_in_par {-> New argpattern.def(expression.expression)} |
    {undef} underscore {-> New argpattern.undef()};




/*******************************************************************
 * Abstract Syntax Tree                                            *
 *******************************************************************/
Abstract Syntax Tree

parse_unit =
  {generated} parse_unit |
  {package} [package]:pragma_id_or_string [imports]:import_package* parse_unit  |
  {unit_alias} [name]:unit_id [content]:unit_content parse_unit |
  {abstract_machine} [variant]:machine_variant [header]:machine_header [machine_clauses]:machine_clause* |
  {refinement_machine} [header]:machine_header [ref_machine]:identifier_literal [machine_clauses]:machine_clause* |
  {implementation_machine} [header]:machine_header [ref_machine]:identifier_literal [machine_clauses]:machine_clause* |
  {definition_file} [definitions_clauses]:machine_clause |
  {predicate} predicate |
  {expression} expression |
  {substitution} substitution |
  {machine_clause} machine_clause |
  {event_b_context} [name]:identifier_literal [context_clauses]:context_clause* |
  {event_b_model} [name]:identifier_literal [model_clauses]:model_clause* |
  {oppattern} [name]:identifier_literal* [parameters]:argpattern* |
  {parse_unit_definition} definition;

import_package = [package]:pragma_id_or_string; // importing a package or machine using import pragma (e.g. /*@import-package "foo.bar" */ )

argpattern = {undef} | {def} expression;
/* csppattern = argtype argpattern; */
/* argtype = {join} | {in} | {out}; */

machine_variant = {machine} | {model} | {system};

machine_header =
  [name]:identifier_literal* [parameters]:expression* ;

context_clause =
  {extends} [extends]:identifier_literal* |
  {sets} set* |
  {constants} [identifiers]:expression* |
  {abstract_constants} [identifiers]:expression* |
  {axioms} [predicates]:predicate* |
  {theorems} [predicates]:predicate* ;


model_clause =
  {refines} [refines]:identifier_literal |
  {sees} [sees]:identifier_literal* |
  {variables} [identifiers]:expression* |
  {invariant} [predicates]:predicate* |
  {theorems} [predicates]:predicate* |
  {variant} [variant]:expression |
  {events} event*;



machine_clause =
  {definitions} [definitions]:definition* |
  {sees} [machine_names]:expression* |
   /* promotes contains operation names, not machine names.
      See http://jira.cobra.cs.uni-duesseldorf.de/browse/PARSERLIB-4  */
  {promotes} [machine_names]:expression* |
  {uses} [machine_names]:expression* |
  {includes} [machine_references]:machine_reference* |
  {extends} [machine_references]:machine_reference* |
  {imports} [machine_references]:machine_reference* |
  {sets} [set_definitions]:set* |
  {freetypes} [freetypes]:freetype* |
  {variables} [identifiers]:expression* |
  {concrete_variables} [identifiers]:expression* |
  {abstract_constants} [identifiers]:expression* |
  {constants} [identifiers]:expression* |
  {properties} [predicates]:predicate |
  {constraints} [predicates]:predicate |
  {initialisation} [substitutions]:substitution |
  {invariant} [predicates]:predicate |
  {assertions} [predicates]:predicate* |
  {values} [entries]:values_entry* |
  {local_operations} [operations]:operation* |
  {operations} [operations]:operation* |
  {references} [identifiers]:expression* |
  {invalid_operations_clause} semicolon ;

machine_reference =
  [machine_name]:identifier_literal* [parameters]:expression* |
  {file} [reference]:machine_reference [file]:pragma_id_or_string ;


definition =
  {conversion} definition |
  {predicate_definition} [name]:def_literal_predicate [parameters]:expression* [rhs]:predicate |
  {substitution_definition} [name]:def_literal_substitution [parameters]:expression* [rhs]:substitution |
  {expression_definition} [name]:identifier_literal [parameters]:expression* [rhs]:expression |
  {file_definition} [filename]:string_literal ;

set =
  {description} T.pragma_free_text set |
  {deferred_set} [identifier]:identifier_literal* |
  {enumerated_set} [identifier]:identifier_literal* [elements]:expression* ;

freetype = [name]:identifier_literal [constructors]:freetype_constructor+ ;
freetype_constructor =
  {constructor} [name]:identifier_literal [argument]:expression |
  {element} [name]:identifier_literal;

values_entry = [identifier]:identifier_literal* [value]:expression ;

operation =
  [return_values]:expression* [op_name]:identifier_literal* [parameters]:expression* [operation_body]:substitution |
  {missing_semicolon} operation |
  {rule} [rule_name]:identifier_literal [attributes]:operation_attribute* [rule_body]:substitution |
  {computation} [name]:identifier_literal [attributes]:operation_attribute* [body]:substitution |
  {function} [return_values]:expression* [name]:identifier_literal [parameters]:expression* [attributes]:operation_attribute* [body]:substitution
  ;

operation_attribute =
  [name]: kw_attribute_identifier [arguments]:expression* |
  {predicate_attribute} [name]:kw_predicate_attribute [predicate]:predicate
  ;

event = [event_name]:identifier_literal [status]:eventstatus [refines]:identifier_literal* [variables]:expression* [guards]:predicate* [theorems]:predicate* [assignments]:substitution* [witness]:witness*;
witness = [name]:identifier_literal [predicate]:predicate;

eventstatus = {ordinary} | {anticipated} | {convergent};

/* Predicates */

predicate =
  {description} [content]:pragma_free_text [predicate]:predicate |
  {label} [name]:pragma_id_or_string [predicate]:predicate |
  {substitution} [substitution]:substitution [predicate]:predicate |
  {conjunct} [left]:predicate [right]:predicate |
  {negation} [predicate]:predicate |
  {disjunct} [left]:predicate [right]:predicate |
  {implication} [left]:predicate [right]:predicate |
  {equivalence} [left]:predicate [right]:predicate |
  {forall} [identifiers]:expression* [implication]:predicate |
  {exists} [identifiers]:expression* [predicate]:predicate |
  {equal} [left]:expression [right]:expression |
  {not_equal} [left]:expression [right]:expression |
  {member} [left]:expression [right]:expression |
  {not_member} [left]:expression [right]:expression |
  {subset} [left]:expression [right]:expression |
  {subset_strict} [left]:expression [right]:expression |
  {not_subset} [left]:expression [right]:expression |
  {not_subset_strict} [left]:expression [right]:expression |
  {less_equal} [left]:expression [right]:expression |
  {less} [left]:expression [right]:expression |
  {greater_equal} [left]:expression [right]:expression |
  {greater} [left]:expression [right]:expression |
  {truth} |
  {falsity} |
  {finite} [set]:expression |
  {partition} [set]:expression [elements]:expression* |    /* Event-B only predicate */
  {definition} [def_literal]:def_literal_predicate [parameters]:expression* |
  {predicate_identifier} [identifier]:predicate_identifier |
  {predicate_function} [identifier]:predicate_identifier [parameters]:expression* |
  {let_predicate} [identifiers]:expression* [assignment]:predicate [pred]:predicate |
  {if_predicate} [condition]:predicate [then]:predicate [else]:predicate |
  {extended_pred} [identifier]:identifier_literal [expressions]:expression* [predicates]:predicate* | /* Event-B only predicate - theory plugin */
  {operator} [name]:kw_predicate_operator [identifiers]:expression* ; // extension for rules

/* Expressions */
expression =
  {file} [identifier]:expression [content]:pragma_id_or_string | // file pragma
  {description} [content]:pragma_free_text [expression]:expression |
  {unit} [content]:unit_content [identifier]:expression |
  {new_unit} [content]:unit_content [identifier]:expression |
  {inferredunit} [content]:unit_content [identifier]:expression |
  {identifier} [identifier]:identifier_literal* |
  {primed_identifier} [identifier]:identifier_literal* [grade]:integer_literal |
  {string} [content]:string_literal |
  {boolean_true} |
  {boolean_false} |
  {integer} [literal]:integer_literal |
  {max_int} |
  {min_int} |
  {empty_set} |
  {integer_set} |
  {natural_set} |
  {natural1_set} |
  {nat_set} |
  {nat1_set} |
  {int_set} |
  {bool_set} |
  {string_set} |
  {convert_bool} [predicate]:predicate |
  {add} [left]:expression [right]:expression |
  {minus} [left]:expression [right]:expression | // only used by EventB translator
  {minus_or_set_subtract} [left]:expression [right]:expression | // used by this parser 'cause we cannot decide which one it is
  {unary_minus} [expression]:expression |
  {multiplication} [left]:expression [right]:expression | // only used by EventB translator
  {cartesian_product} [left]:expression [right]:expression | // only used by EventB translator
  {mult_or_cart} [left]:expression [right]:expression | // used by this parser 'cause we cannot decide which one it is
  {div} [left]:expression [right]:expression |
  {floored_div} [left]:expression [right]:expression | /* has no concrete syntax, generated for example by TLA translation */
  {if_then_else} [condition]:predicate [then]:expression [else]:expression |
  {let_expression} [identifiers]:expression* [assignment]:predicate [expr]:expression |
  {modulo} [left]:expression [right]:expression |
  {power_of} [left]:expression [right]:expression |
  {successor} |
  {predecessor} |
  {max} [expression]:expression |
  {min} [expression]:expression |
  {card} [expression]:expression |
  {general_sum} [identifiers]:expression* [predicates]:predicate [expression]:expression |
  {general_product} [identifiers]:expression* [predicates]:predicate [expression]:expression |
  {couple} [list]:expression* |
  {comprehension_set} [identifiers]:expression* [predicates]:predicate |
  {symbolic_comprehension_set} [identifiers]:expression* [predicates]:predicate |
  {prover_comprehension_set} [identifiers]:expression* [predicates]:predicate | // todo: fix this special case
  {event_b_comprehension_set} [identifiers]:expression* [expression]:expression [predicates]:predicate | // EventB only
  {pow_subset} [expression]:expression |
  {pow1_subset} [expression]:expression |
  {fin_subset} [expression]:expression |
  {fin1_subset} [expression]:expression |
  {set_extension} [expressions]:expression* |
  {interval} [left_border]:expression [right_border]:expression |
  {union} [left]:expression [right]:expression |
  {intersection} [left]:expression [right]:expression |
  {set_subtraction} [left]:expression [right]:expression |
  {general_union} [expression]:expression |
  {general_intersection} [expression]:expression |
  {quantified_union} [identifiers]:expression* [predicates]:predicate [expression]:expression |
  {quantified_intersection} [identifiers]:expression* [predicates]:predicate [expression]:expression |
  {relations} [left]:expression [right]:expression |
  {identity} [expression]:expression |
  {event_b_identity}  | // EventB v 2.0 language only
  {reverse} [expression]:expression |
  {first_projection} [exp1]:expression [exp2]:expression |
  {event_b_first_projection} [expression]:expression | // EventB only
  {event_b_first_projection_v2} | // EventB v 2.0 language only
  {second_projection} [exp1]:expression [exp2]:expression |
  {event_b_second_projection}  [expression]:expression | // EventB only
  {event_b_second_projection_v2} | // EventB v 2.0 language only
  {composition} [left]:expression [right]:expression |
  {ring} [left]:expression [right]:expression | // EventB only
  {direct_product} [left]:expression [right]:expression |
  {parallel_product} [left]:expression [right]:expression |
  {iteration} [left]:expression [right]:expression |
  {reflexive_closure} [expression]:expression |
  {closure} [expression]:expression |
  {domain} [expression]:expression |
  {range} [expression]:expression |
  {image} [left]:expression [right]:expression |
  {domain_restriction} [left]:expression [right]:expression |
  {domain_subtraction} [left]:expression [right]:expression |
  {range_restriction} [left]:expression [right]:expression |
  {range_subtraction} [left]:expression [right]:expression |
  {overwrite} [left]:expression [right]:expression |
  {partial_function} [left]:expression [right]:expression |
  {total_function} [left]:expression [right]:expression |
  {partial_injection} [left]:expression [right]:expression |
  {total_injection} [left]:expression [right]:expression |
  {partial_surjection} [left]:expression [right]:expression |
  {total_surjection} [left]:expression [right]:expression |
  {partial_bijection} [left]:expression [right]:expression |
  {total_bijection} [left]:expression [right]:expression |
  {total_relation} [left]:expression [right]:expression | // EventB only
  {surjection_relation} [left]:expression [right]:expression | // EventB only
  {total_surjection_relation} [left]:expression [right]:expression | // EventB only
  {lambda} [identifiers]:expression* [predicate]:predicate [expression]:expression |
  {symbolic_lambda} [identifiers]:expression* [predicate]:predicate [expression]:expression |
  {trans_function} [expression]:expression |
  {trans_relation} [expression]:expression |
  {seq} [expression]:expression |
  {seq1} [expression]:expression |
  {iseq} [expression]:expression |
  {iseq1} [expression]:expression |
  {perm} [expression]:expression |
  {empty_sequence} |
  {sequence_extension} [expression]:expression* |
  {size} [expression]:expression |
  {first} [expression]:expression |
  {last} [expression]:expression |
  {front} [expression]:expression |
  {tail} [expression]:expression |
  {rev} [expression]:expression |
  {concat} [left]:expression [right]:expression |
  {insert_front} [left]:expression [right]:expression |
  {insert_tail} [left]:expression [right]:expression |
  {restrict_front} [left]:expression [right]:expression |
  {restrict_tail} [left]:expression [right]:expression |
  {general_concat} [expression]:expression |
  {definition} [def_literal]:identifier_literal [parameters]:expression* |
  {function} [identifier]:expression [parameters]:expression* |
  {tree} [expression]:expression |
  {btree} [expression]:expression |
  {const} [expression1]:expression [expression2]:expression |
  {top} [expression]:expression |
  {sons} [expression]:expression |
  {prefix} [expression]:expression |
  {postfix} [expression]:expression |
  {sizet} [expression]:expression |
  {mirror} [expression]:expression |
  {rank} [expression1]:expression [expression2]:expression |
  {father} [expression1]:expression [expression2]:expression |
  {son} [expression1]:expression [expression2]:expression [expression3]:expression |
  {subtree} [expression1]:expression [expression2]:expression |
  {arity} [expression1]:expression [expression2]:expression |
  {bin} [expression1]:expression [expression2]:expression? [expression3]:expression? |
  {left} [expression]:expression |
  {right} [expression]:expression |
  {infix} [expression]:expression |
  {struct} [entries]:rec_entry* |
  {rec} [entries]:rec_entry* |
  {record_field} [record]:expression [identifier]:expression |
  {extended_expr} [identifier]:identifier_literal [expressions]:expression* [predicates]:predicate* | /* Event-B only expression - theory plugin */
  {typeof} [expression]:expression [type]:expression | /* Has no concrete syntax, is only generated by the translation process */
  {operation_call} [operation]:identifier_literal* [parameters]:expression* |
  {operator} [name]:kw_expression_operator [identifiers]:expression* // extension for rules
  ;

rec_entry = [identifier]:expression [value]:expression;



/* Substitutions */
substitution =
  {block} [substitution]:substitution |
  {skip} |
  {assign} [lhs_expression]:expression* [rhs_expressions]:expression* |
  {precondition} [predicate]:predicate [substitution]:substitution |
  {assertion} [predicate]:predicate [substitution]:substitution |
  {choice} [substitutions]:substitution* |
  {choice_or} [substitution]:substitution |
  {if} [condition]:predicate [then]:substitution [elsif_substitutions]:substitution* [else]:substitution? |
  {if_elsif} [condition]:predicate [then_substitution]:substitution |
  {select} [condition]:predicate [then]:substitution [when_substitutions]:substitution* [else]:substitution? |
  {select_when} [condition]:predicate [substitution]:substitution |
  {case} expression [either_expr]:expression* [either_subst]:substitution [or_substitutions]:substitution* [else]:substitution? |
  {case_or} [expressions]:expression* [substitution]:substitution |
  {any} [identifiers]:expression* [where]:predicate [then]:substitution |
  {let} [identifiers]:expression* [predicate]:predicate [substitution]:substitution |
  {becomes_element_of} [identifiers]:expression* [set]:expression|
  {becomes_such} [identifiers]:expression* [predicate]:predicate |
  {var} [identifiers]:expression* [substitution]:substitution |
  {sequence} [substitutions]:substitution* |
  {func_op} [function]:expression |
  {op} [name]:expression [parameters]:expression* |
  {operation_call} [result_identifiers]:expression* [operation]:identifier_literal* [parameters]:expression* |
  {while} [condition]:predicate [do_subst]:substitution [invariant]:predicate [variant]:expression |
  {parallel} [substitutions]:substitution* |
  {definition} [def_literal]:def_literal_substitution [parameters]:expression* |
  {invalid} semicolon |
  {forall_sub_message} [identifiers]:expression* [where]:predicate [expect]:predicate [error_type]:integer_literal? [message]:expression | //extension for rules
  {rule_any_sub_message}  [identifiers]:expression* [where]:predicate [error_type]:integer_literal? [message]:expression | //extension for rules
  {for_loop} [identifier]:expression [set]:expression [do_subst]:substitution | //extension for rules
  {operator} [name]:kw_substitution_operator [arguments]:expression* | //extension for rules
  {define} [name]:identifier_literal [type]:expression [dummy_value]:expression? [value]:expression ; //extension for rules
